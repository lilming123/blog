<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lilming的编程方舟</title>
  
  
  <link href="https://coding.lilming.top/atom.xml" rel="self"/>
  
  <link href="https://coding.lilming.top/"/>
  <updated>2023-09-14T15:59:22.426Z</updated>
  <id>https://coding.lilming.top/</id>
  
  <author>
    <name>lilming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo标签外挂</title>
    <link href="https://coding.lilming.top/2023/09/13/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/hexo%E6%A0%87%E7%AD%BE%E5%A4%96%E6%8C%82/"/>
    <id>https://coding.lilming.top/2023/09/13/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/hexo%E6%A0%87%E7%AD%BE%E5%A4%96%E6%8C%82/</id>
    <published>2023-09-13T00:25:00.000Z</published>
    <updated>2023-09-14T15:59:22.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;  </span><br><span class="line">Any content (support inline tags too.io).  </span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>用法</th></tr></thead><tbody><tr><td>class</td><td>【可选】标识，不同的标识有不同的配色  <br>（ default &#x2F; primary &#x2F; success &#x2F; info &#x2F; warning &#x2F; danger ）</td></tr><tr><td>no-icon</td><td>【可选】不显示 icon</td></tr><tr><td>style</td><td>【可选】可以覆盖配置中的 style  <br>（simple&#x2F;modern&#x2F;flat&#x2F;disabled）</td></tr></tbody></table><p>例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;  </span><br><span class="line">默认 提示块标签  </span><br><span class="line">&#123;% endnote %&#125;  </span><br><span class="line">&#123;% note default flat %&#125;  </span><br><span class="line">default 提示块标签  </span><br><span class="line">&#123;% endnote %&#125;  </span><br><span class="line">&#123;% note primary flat %&#125;  </span><br><span class="line">primary 提示块标签  </span><br><span class="line">&#123;% endnote %&#125;  </span><br><span class="line">&#123;% note success flat %&#125;  </span><br><span class="line">success 提示块标签  </span><br><span class="line">&#123;% endnote %&#125;  </span><br><span class="line">&#123;% note info flat %&#125;  </span><br><span class="line">info 提示块标签  </span><br><span class="line">&#123;% endnote %&#125;  </span><br><span class="line">&#123;% note warning flat %&#125;  </span><br><span class="line">warning 提示块标签  </span><br><span class="line">&#123;% endnote %&#125;  </span><br><span class="line">&#123;% note danger flat %&#125;  </span><br><span class="line">danger 提示块标签  </span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>预览：</p><div class="note flat"><p>默认提示块标签  </p></div>  <div class="note default flat"><p>default 提示块标签  </p></div>  <div class="note primary flat"><p>primary 提示块标签  </p></div>  <div class="note success flat"><p>success 提示块标签  </p></div>  <div class="note info flat"><p>info 提示块标签  </p></div>  <div class="note warning flat"><p>warning 提示块标签  </p></div>  <div class="note danger flat"><p>danger 提示块标签  </p></div><h1 id="Tag-hide"><a href="#Tag-hide" class="headerlink" title="Tag-hide"></a>Tag-hide</h1><p>如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。( display 不能包含英文逗号，可用 <code>&amp;sbquo;</code>)</p><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>content <span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideToggle Butterfly安装方法 %&#125;  </span><br><span class="line">在你的博客根目录里  </span><br><span class="line">  </span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly  </span><br><span class="line">  </span><br><span class="line">如果想要安装比较新的dev分支，可以  </span><br><span class="line">  </span><br><span class="line">git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly  </span><br><span class="line">  </span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><details class="toggle" ><summary class="toggle-button" style="">Butterfly 安装方法</summary><div class="toggle-content"><p>在你的博客根目录里  </p><p>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes&#x2F;Butterfly  </p><p>如果想要安装比较新的 dev 分支，可以  </p><p>git clone -b dev <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes&#x2F;Butterfly    </p></div></details><h1 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h1><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;  </span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;  </span><br><span class="line">Any content (support inline tags too).  </span><br><span class="line">&lt;!-- endtab --&gt;  </span><br><span class="line">&#123;% endtabs %&#125;  </span><br><span class="line">  </span><br><span class="line">Unique name   : Unique name of tabs block tag without comma.  </span><br><span class="line"><span class="code">                Will be used in #id&#x27;s as prefix for each tab with their index numbers.  </span></span><br><span class="line"><span class="code">                If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.  </span></span><br><span class="line"><span class="code">                Only for current url of post/page must be unique!  </span></span><br><span class="line"><span class="code">[index]       : Index number of active tab.  </span></span><br><span class="line"><span class="code">                If not specified, first tab (1) will be selected.  </span></span><br><span class="line"><span class="code">                If index is -1, no tab will be selected. It&#x27;s will be something like spoiler.  </span></span><br><span class="line"><span class="code">                Optional parameter.  </span></span><br><span class="line"><span class="code">[Tab caption] : Caption of current tab.  </span></span><br><span class="line"><span class="code">                If not caption specified, unique name with tab index suffix will be used as caption of tab.  </span></span><br><span class="line"><span class="code">                If not caption specified, but specified icon, caption will empty.  </span></span><br><span class="line"><span class="code">                Optional parameter.  </span></span><br><span class="line"><span class="code">[@icon]       : FontAwesome icon name (full-name, look like &#x27;fas fa-font&#x27;)  </span></span><br><span class="line"><span class="code">                Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;.  </span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Tab %&#125;  </span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;  </span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span>  </span><br><span class="line">&lt;!-- endtab --&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- tab 第二个Tab --&gt;  </span><br><span class="line"><span class="strong">**tab名字为第二个Tab**</span>  </span><br><span class="line">&lt;!-- endtab --&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- tab 第三个Tab --&gt;  </span><br><span class="line"><span class="strong">**tab名字为第三个Tab**</span>  </span><br><span class="line">&lt;!-- endtab --&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;  </span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span>  </span><br><span class="line">&lt;!-- endtab --&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;  </span><br><span class="line"><span class="strong">**名字+icon**</span>  </span><br><span class="line">&lt;!-- endtab --&gt;  </span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#tab-2">第二个Tab</button></li><li class="tab"><button type="button" data-href="#tab-3">第三个Tab</button></li><li class="tab"><button type="button" data-href="#tab-4"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#tab-5"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab-1"><p><strong>tab名字为第一个Tab</strong>  </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-2"><p><strong>tab名字为第二个Tab</strong>  </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-3"><p><strong>tab名字为第三个Tab</strong>  </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-4"><p><strong>只有图标 没有Tab名字</strong>  </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-5"><p><strong>名字+icon</strong>  </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;  </span><br><span class="line">  </span><br><span class="line">[url]         : 链接  </span><br><span class="line">[text]        : 按钮文字  </span><br><span class="line">[icon]        : [可选] 图标  </span><br><span class="line">[color]       : [可选] 按钮背景顔色(默认style时）  </span><br><span class="line"><span class="code">                      按钮字体和边框顔色(outline时)  </span></span><br><span class="line"><span class="code">                      default/blue/pink/red/purple/orange/green  </span></span><br><span class="line"><span class="code">[style]       : [可选] 按钮样式 默认实心  </span></span><br><span class="line"><span class="code">                      outline/留空  </span></span><br><span class="line"><span class="code">[layout]      : [可选] 按钮佈局 默认为line  </span></span><br><span class="line"><span class="code">                      block/留空  </span></span><br><span class="line"><span class="code">[position]    : [可选] 按钮位置 前提是设置了layout为block 默认为左边  </span></span><br><span class="line"><span class="code">                      center/right/留空  </span></span><br><span class="line"><span class="code">[size]        : [可选] 按钮大小  </span></span><br><span class="line"><span class="code">                      larger/留空</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-center&quot;</span>&gt;</span></span>  </span><br><span class="line">&#123;% btn &#x27;https://blog.falling42.top/&#x27;,Falling42のBlog,far fa-hand-point-right,larger %&#125;  </span><br><span class="line">&#123;% btn &#x27;https://blog.falling42.top/&#x27;,Falling42のBlog,far fa-hand-point-right,blue larger %&#125;  </span><br><span class="line">&#123;% btn &#x27;https://blog.falling42.top/&#x27;,Falling42のBlog,far fa-hand-point-right,pink larger %&#125;  </span><br><span class="line">&#123;% btn &#x27;https://blog.falling42.top/&#x27;,Falling42のBlog,far fa-hand-point-right,red larger %&#125;  </span><br><span class="line">&#123;% btn &#x27;https://blog.falling42.top/&#x27;,Falling42のBlog,far fa-hand-point-right,block outline purple larger %&#125;  </span><br><span class="line">&#123;% btn &#x27;https://blog.falling42.top/&#x27;,Falling42のBlog,far fa-hand-point-right,block center outline orange larger %&#125;  </span><br><span class="line">&#123;% btn &#x27;https://blog.falling42.top/&#x27;,Falling42のBlog,far fa-hand-point-right,block right outline green larger %&#125;  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><div class="btn-center">  <a class="btn-beautify larger" href="https://blog.falling42.top/"   title="Falling42のBlog"><i class="far fa-hand-point-right"></i><span>Falling42のBlog</span></a>  <a class="btn-beautify blue larger" href="https://blog.falling42.top/"   title="Falling42のBlog"><i class="far fa-hand-point-right"></i><span>Falling42のBlog</span></a>  <a class="btn-beautify pink larger" href="https://blog.falling42.top/"   title="Falling42のBlog"><i class="far fa-hand-point-right"></i><span>Falling42のBlog</span></a>  <a class="btn-beautify red larger" href="https://blog.falling42.top/"   title="Falling42のBlog"><i class="far fa-hand-point-right"></i><span>Falling42のBlog</span></a>  <a class="btn-beautify block outline purple larger" href="https://blog.falling42.top/"   title="Falling42のBlog"><i class="far fa-hand-point-right"></i><span>Falling42のBlog</span></a>  <a class="btn-beautify block center outline orange larger" href="https://blog.falling42.top/"   title="Falling42のBlog"><i class="far fa-hand-point-right"></i><span>Falling42のBlog</span></a>  <a class="btn-beautify block right outline green larger" href="https://blog.falling42.top/"   title="Falling42のBlog"><i class="far fa-hand-point-right"></i><span>Falling42のBlog</span></a>  </div><h1 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h1><p>高亮所需的文字</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>text</td><td>文字</td></tr><tr><td>color</td><td>【可选】背景颜色，默认为 default  <br>default&#x2F;blue&#x2F;pink&#x2F;red&#x2F;purple&#x2F;orange&#x2F;green</td></tr></tbody></table><p>例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">臣亮言：&#123;% label 先帝 %&#125;创业未半，而&#123;% label 中道崩殂 blue %&#125;。今天下三分，&#123;% label 益州疲敝 pink %&#125;，此诚&#123;% label 危急存亡之秋 red %&#125;也！然侍衞之臣，不懈于内；&#123;% label 忠志之士 purple %&#125;，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。  </span><br><span class="line">宫中、府中，俱为一体；陟罚臧否，不宜异同。若有&#123;% label 作奸 orange %&#125;、&#123;% label 犯科 green %&#125;，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</span><br></pre></td></tr></table></figure><p>预览：<br>臣亮言：<mark class="hl-label default">先帝</mark> 创业未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此诚<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈于内；<mark class="hl-label purple">忠志之士</mark> ，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中、府中，俱为一体；陟罚臧否，不宜异同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</p><h1 id="inlineimg"><a href="#inlineimg" class="headerlink" title="inlineimg"></a>inlineimg</h1><p>主题中的图片都是默认以块级元素显示，如果你想以内联元素显示，可以使用这个标签外挂。</p><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineImg [src] [height] %&#125;  </span><br><span class="line">  </span><br><span class="line">[src]      :    图片链接  </span><br><span class="line">[height]   ：   图片高度限制【可选】</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是&#123;% inlineImg https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif 20px %&#125; 一段话。  </span><br><span class="line">  </span><br><span class="line">这是&#123;% inlineImg https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif 40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><p>预览：<br>这是<img class="inline-img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:20px"/> 一段话。  </p><p>这是<img class="inline-img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px"/> 一段话。</p><h1 id="Mermai"><a href="#Mermai" class="headerlink" title="Mermai"></a>Mermai</h1><p>用 mermaid 标籤可以绘製 Flowchart（流程图）、Sequence diagram（时序图 ）、Class Diagram（类别图）、State Diagram（状态图）、Gantt（甘特图）和 Pie Chart（圆形图），具体可以查看 <a href="https://mermaid-js.github.io/mermaid/#/">mermaid 文档</a></p><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;  </span><br><span class="line">mermaid语法</span><br><span class="line">&#123;% endmermaid %</span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  &lt;br&gt;pie  &lt;br&gt;    title Key elements in Product X  &lt;br&gt;    &quot;Calcium&quot; : 42.96  &lt;br&gt;    &quot;Potassium&quot; : 50.05  &lt;br&gt;    &quot;Magnesium&quot; : 10.01  &lt;br&gt;    &quot;Iron&quot; :  5  &lt;br&gt;  </pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Note&quot;&gt;&lt;a href=&quot;#Note&quot; class=&quot;headerlink&quot; title=&quot;Note&quot;&gt;&lt;/a&gt;Note&lt;/h1&gt;&lt;p&gt;语法：&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas</summary>
      
    
    
    
    <category term="博客搭建与配置" scheme="https://coding.lilming.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot接入阿里云SLS云日志服务</title>
    <link href="https://coding.lilming.top/2023/09/12/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/SpringBoot%E6%8E%A5%E5%85%A5%E9%98%BF%E9%87%8C%E4%BA%91SLS%E4%BA%91%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1/"/>
    <id>https://coding.lilming.top/2023/09/12/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/SpringBoot%E6%8E%A5%E5%85%A5%E9%98%BF%E9%87%8C%E4%BA%91SLS%E4%BA%91%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-09-12T08:13:00.000Z</published>
    <updated>2023-09-14T07:53:53.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>本教程需要先完成以下工作，若已完成可直接跳到第二部分</p><ol><li>获取阿里云账号的 AccessKey 以及 AccessKey Secret。（建议使用 RAM 访问控制，仅授权部分权限）</li><li>开通阿里云 SLS 服务，创建 Project 和 logstore</li></ol><details class="toggle" ><summary class="toggle-button" style="">准备工作</summary><div class="toggle-content"><ol><li>要使用阿里云的云服务要先注册阿里云的账号，点击右上角的头像，进入 AccessKey，获取 AccessKey 以及 AccessKey Secret。官方建议使用 RAM 仅开放有限的权限，可查看官方文档的具体操作： <a href="https://help.aliyun.com/zh/ram/getting-started/create-a-ram-user-1">官方文档</a><br><a href="https://sls.console.aliyun.com/lognext/profile">sls 控制台，点击跳转</a></li></ol><p><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913082917.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913082948.png"><br>2. 开通阿里云 SLS，创建 Project,这里名字命名为 school-accounting，注意分隔符是 <code>-</code> 不是 <code>_</code><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913083948.png"><br><strong>注意地域要选择和服务器同一地域的</strong><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913084052.png"><br>3. 创建 Logstore，这里名字命名为 cost_center<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913084859.png"><br>4. 在记下地域所属的 endpoint，之后会用到<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913084722.png"></p></div></details><h1 id="在-SpringBoot-中配置SLS"><a href="#在-SpringBoot-中配置SLS" class="headerlink" title="在 SpringBoot 中配置SLS"></a>在 SpringBoot 中配置SLS</h1><p>SpringBoot 支持多种日志框架，如 JavaUtilLogging，Log4J，Log4J2和 Logback。SpringBoot 默认采用 <code>Logback</code> 如没有特别需求，使用 Logback<br>即可，这里的示例也是采用 Logback</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol><li>在项目的启动模块的 <code>pom.xml</code> 中加入阿里云 sls 相关的依赖,并且重新生成 <code>Maven项目依赖</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.openservices<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-log-logback-appender<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>修改 <code>resources</code> 文件夹下的 <code>logback-spring.xml</code> 文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--阿里云SLS--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--为了防止进程退出时，内存中的数据丢失，请加上此选项--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">shutdownHook</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.hook.DelayingShutdownHook&quot;</span>/&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;loghubAppender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.aliyun.openservices.log.logback.LoghubAppender&quot;</span>&gt;</span>  </span><br><span class="line">   <span class="comment">&lt;!--必选项--&gt;</span>  </span><br><span class="line">   <span class="comment">&lt;!-- 账号及网络配置 --&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">endpoint</span>&gt;</span>你的endpoint<span class="tag">&lt;/<span class="name">endpoint</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">accessKeyId</span>&gt;</span>accessKeyId<span class="tag">&lt;/<span class="name">accessKeyId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">accessKeySecret</span>&gt;</span>你的accessKeySecret<span class="tag">&lt;/<span class="name">accessKeySecret</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">&lt;!-- sls 项目配置 --&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">project</span>&gt;</span>school-accounting<span class="tag">&lt;/<span class="name">project</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">logStore</span>&gt;</span>cost_center<span class="tag">&lt;/<span class="name">logStore</span>&gt;</span>  </span><br><span class="line">   <span class="comment">&lt;!--必选项 (end)--&gt;</span>   <span class="tag">&lt;<span class="name">totalSizeInBytes</span>&gt;</span>104857600<span class="tag">&lt;/<span class="name">totalSizeInBytes</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">maxBlockMs</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxBlockMs</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">ioThreadCount</span>&gt;</span>8<span class="tag">&lt;/<span class="name">ioThreadCount</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">batchSizeThresholdInBytes</span>&gt;</span>524288<span class="tag">&lt;/<span class="name">batchSizeThresholdInBytes</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">batchCountThreshold</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">batchCountThreshold</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">lingerMs</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">lingerMs</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">retries</span>&gt;</span>10<span class="tag">&lt;/<span class="name">retries</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">baseRetryBackoffMs</span>&gt;</span>100<span class="tag">&lt;/<span class="name">baseRetryBackoffMs</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">maxRetryBackoffMs</span>&gt;</span>50000<span class="tag">&lt;/<span class="name">maxRetryBackoffMs</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">   <span class="tag">&lt;<span class="name">encoder</span>&gt;</span>      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %-5level [%thread] %logger&#123;0&#125;: %msg<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span>  </span><br><span class="line">   <span class="comment">&lt;!-- 只打印INFO级别的日志 --&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--阿里云SLS (end)--&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以上配置之后还没有指定哪个模块输出的日志要上传的 sls 中，下面的配置根据项目的具体需求来选择，这里演示了两种:</p></blockquote></li></ol><div class="tabs" id="sls"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#sls-1">指定业务中的类才会接入sls</button></li><li class="tab"><button type="button" data-href="#sls-2">所有的日志都接入到sls中</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="sls-1"><p>例如以下只有拦截器中的日志会被输入到 sls 中，其中 <code>loghubAppender</code> 是上面的配置的 appender name，会输入到 sls 中；STDOUT 是同时也在输出到控制台中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.jeecg.config.mybatis.MybatisInterceptor&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;loghubAppender&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="sls-2"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;HTML&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE_HTML&quot;</span> /&gt;</span>  </span><br><span class="line">+<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;loghubAppender&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="在程序中输出日志"><a href="#在程序中输出日志" class="headerlink" title="在程序中输出日志"></a>在程序中输出日志</h2><p>在下列的示例中，拦截了 mybatis 的插入方法，指定了特定的表，将插入的对象以支付串的形式输出。当系统往 <code>cd_calc_main</code> 表中插入记录时，会往 sls 中输出日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Intercepts(&#123; @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123; MappedStatement.class, Object.class &#125;),  </span></span><br><span class="line"><span class="meta">      @Signature(type = StatementHandler.class, method = &quot;prepare&quot;, args = &#123;Connection.class, Integer.class&#125;)  </span></span><br><span class="line"><span class="meta">&#125;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MybatisInterceptor.class);  </span><br><span class="line">   </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">if</span> (SqlCommandType.INSERT == sqlCommandType) &#123;  </span><br><span class="line"></span><br><span class="line"><span class="type">MappedStatement</span> <span class="variable">mappedStatement</span> <span class="operator">=</span> (MappedStatement) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//其他代码省略</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//写入阿里云的sls中  </span></span><br><span class="line">   <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> mappedStatement.getBoundSql(parameter);  </span><br><span class="line">   <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();  </span><br><span class="line">   <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> getTableNameFromSql(sql);  </span><br><span class="line">   <span class="keyword">if</span> (Objects.equals(tableName, <span class="string">&quot;cd_calc_main&quot;</span>))&#123;  </span><br><span class="line">      <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">      <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(parameter);  </span><br><span class="line">      logger.info(json);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取插入数据sql的表名，匹配into后面的单词</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">TABLE_NAME_PATTERN</span> <span class="operator">=</span>  </span><br><span class="line">      Pattern.compile(<span class="string">&quot;\\binto\\b\\s*(\\w+)&quot;</span>, Pattern.CASE_INSENSITIVE);  </span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getTableNameFromSql</span><span class="params">(String sql)</span> &#123;  </span><br><span class="line">   <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> TABLE_NAME_PATTERN.matcher(sql);  </span><br><span class="line">   <span class="keyword">if</span> (matcher.find()) &#123;  </span><br><span class="line">      <span class="keyword">return</span> matcher.group(<span class="number">1</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行项目，预览数据接入情况"><a href="#运行项目，预览数据接入情况" class="headerlink" title="运行项目，预览数据接入情况"></a>运行项目，预览数据接入情况</h2><p>点击右侧边栏数据接入的＋号<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913085917.png"></p><p>阿里云的 SLS 支持 JAVA 的 Logback、Log4J 和 Log4J2，在弹出窗口中点击 <code>LogBack接入</code><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913085712.png"></p><p>之后运行程序，在预览界面查看 sls 接受到的日志数据<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913101935.png"></p><p>SLS 中一个十分好用的功能是 <code>自动生成索引</code>，在上面的例子中我们把 CdCalcMain 对象的每个属性转换成了 <code>Json</code> 格式的字符串作为 message 的 value，点击 <code>自动生成索引</code>，SLS 能自动试别 message 为 <code>json</code> 格式，标记了每个 key 值<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913143106.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230913143354.png"><br>观察输出的日志格式，有以下几个字段：</p><ol><li>__source__：表示发出日志的 ip 地址，在本实例中就是本机的 ip 地址</li><li>__topic__：日志主题，可以在 <code>logback-spring.xml</code> 中配置</li><li>location：是程序输出的位置</li><li>log：是程序控制台输出日志的内容</li><li>message：是日志输出的内容</li></ol>]]></content>
    
    
    <summary type="html">本学期会计大数据课程的第一个小组作业，对材料中利用云日志同一采集数据比较感兴趣，在这里基于springboot的logback日志输出的基础上，引入阿里云相关依赖，在指定的类中输出日志到阿里云SLS中，并储存到阿里云OSS中</summary>
    
    
    
    <category term="后端学习" scheme="https://coding.lilming.top/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="java" scheme="https://coding.lilming.top/tags/java/"/>
    
    <category term="云日志" scheme="https://coding.lilming.top/tags/%E4%BA%91%E6%97%A5%E5%BF%97/"/>
    
    <category term="大数据" scheme="https://coding.lilming.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB基础语法</title>
    <link href="https://coding.lilming.top/2023/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://coding.lilming.top/2023/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2023-09-11T03:10:00.000Z</published>
    <updated>2023-09-14T16:05:55.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载数据库"><a href="#下载数据库" class="headerlink" title="下载数据库"></a>下载数据库</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下载数据库&quot;&gt;&lt;a href=&quot;#下载数据库&quot; class=&quot;headerlink&quot; title=&quot;下载数据库&quot;&gt;&lt;/a&gt;下载数据库&lt;/h1&gt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://coding.lilming.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>写了三年博客，有一些想说的话</title>
    <link href="https://coding.lilming.top/2023/09/10/%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%86%99%E4%BA%86%E4%B8%89%E5%B9%B4%E5%8D%9A%E5%AE%A2%EF%BC%8C%E6%9C%89%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/"/>
    <id>https://coding.lilming.top/2023/09/10/%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%86%99%E4%BA%86%E4%B8%89%E5%B9%B4%E5%8D%9A%E5%AE%A2%EF%BC%8C%E6%9C%89%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/</id>
    <published>2023-09-10T12:01:00.000Z</published>
    <updated>2023-09-14T08:26:19.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些心得✍"><a href="#一些心得✍" class="headerlink" title="一些心得✍"></a>一些心得✍</h1><p>使用博客也算是很长时间了，其实博客也无非就是四个核心部分组成：</p><ol><li>博客生成框架</li><li>文件托管平台</li><li>站点生成服务</li><li>访问加速服务</li></ol><p>博客生成框架我使用过的有 wordpress、Typecho、hexo、hugo，其中 wordpress 和 Typecho 类似，hexo 和 hugo 类似，前两种自定义程度较低，适合小白，后两种自定义程度较高，适合有基础的人</p><p>说说我认为最佳的博客解决方案吧：</p><ol><li>笔记软件：Obsidian，在 <code>soruce//_post</code> 下写文章</li><li>git：使用 Obsidian 插件，设置固定的时间间隔上传，无需手动提交</li><li>博客生成框架：hexop</li><li>文件托管平台：github</li><li>站点生成服务：netlify，同时运行命令设置为<code>npm run clean &amp;&amp; npm run build</code></li><li>访问加速服务：cloudflare<br>其中前两步不是必须的， Typora 也可以，只是提供一个思路，能将同步 + 渲染 ＋ 部署这一套流程自动化的都是好方案。</li></ol><h1 id="关于这次魔改"><a href="#关于这次魔改" class="headerlink" title="关于这次魔改"></a>关于这次魔改</h1><p>自从上个学期云服务器到期，域名转手（之前的域名 lilmingcoding.top 10 块买的转手 280 卖了，简直血赚）我的博客就一直是毛坯房的状态，只是一个 hexo 的默认主题，让人看着一点创作欲望也没有，那时我临近期末考了就一直搁置到了暑假，而在假期心事也渐渐不在博客上了，果然博客还是不能拖啊。而在几天之前，软著和实习都差不多结束了，我这才开始着手美化。</p><p>魔改的样式是模仿的店长的 <a href="https://akilar.top/">源计划-方舟</a> ，然而个人实力有限，很多功能没有实现，比如加载框我只能用一个丐版的（笑），店长的加载框是真的帅，科技风满满。还有一些细节还没有完善，不过也差不多了，很快就能写好。</p><p>总的来说，这次魔改还是比较满意的，不过过程不太顺利，<code>Stylus</code> 写起来很不习惯，但是有点 css 基础的都能改；主要是 <code>pug</code> 简直对我来说是一门新的语言，只能现学了。最终效果也是有赛博朋克那味了哈哈哈，先立个 flag 哈，下个学期多多内容输出，一周至少两更。</p><h1 id="为何要创建博客🤔"><a href="#为何要创建博客🤔" class="headerlink" title="为何要创建博客🤔"></a>为何要创建博客🤔</h1><p>其实很多博主都会被问到这个问题，或许在看这篇博文的你也有同样的困惑，分享日常有朋友圈、小红书，交流技术有开源社区，为什么还要费这么大劲，又是学习博客框架，又是部署托管，对颜值有要求的可能还要像我魔改，<del>写出来还没人看（笑）😂</del>。三年前暑假，高考完的我懵懵懂懂，在宝塔上用 wordpress 成功运行了属于我的第一个网站，这对于那时的我来说不单单有一种踏入新世界的好奇，更多的是各种技术运用所带来的成就感，如果你问三年前的我，我的回答会是：因为有趣。</p><p>是的我创建博客的理由很简单，就是因为酷，想展现自己的技术力<del>装逼</del>，这又未尝不可呢。然而坚持写博客的理由却不一样，一时的热血和激情过去，等待博客的只是死刑缓期的搁置，仅仅一个简单甚至幼稚的理由不可能坚持三年。我不管是待人还是处事都是 <code>爱好驱动</code>，我很喜欢一句话，<code>热爱可抵岁月漫长</code>，即使我转专业失败也至今没有放弃编程，主动去认识了很多技术大佬，尽可能去参加任何对自己有帮助的活动，比如实习、OSPP、字节青训营，同时也是为自己打破信息壁垒。因此，我现在的回复是：<strong>想拥有一个属于自己的技术圈子</strong>  。当然开源社区也能满足，但是过多的限制也会让人抓狂，我是个不喜欢被约束的人，搭博客肯定是首选。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些心得✍&quot;&gt;&lt;a href=&quot;#一些心得✍&quot; class=&quot;headerlink&quot; title=&quot;一些心得✍&quot;&gt;&lt;/a&gt;一些心得✍&lt;/h1&gt;&lt;p&gt;使用博客也算是很长时间了，其实博客也无非就是四个核心部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;博客生成框架&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="碎碎念" scheme="https://coding.lilming.top/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Go语言基础入门</title>
    <link href="https://coding.lilming.top/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://coding.lilming.top/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2023-09-07T05:19:00.000Z</published>
    <updated>2023-09-10T12:21:47.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-内置类型和函数"><a href="#Golang-内置类型和函数" class="headerlink" title="Golang 内置类型和函数"></a>Golang 内置类型和函数</h1><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><h3 id="值类型："><a href="#值类型：" class="headerlink" title="值类型："></a>值类型：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="type">int</span>(<span class="number">32</span> or <span class="number">64</span>), <span class="type">int8</span>, <span class="type">int16</span>, <span class="type">int32</span>, <span class="type">int64</span></span><br><span class="line"><span class="type">uint</span>(<span class="number">32</span> or <span class="number">64</span>), <span class="type">uint8</span>(<span class="type">byte</span>), <span class="type">uint16</span>, <span class="type">uint32</span>, <span class="type">uint64</span></span><br><span class="line"><span class="type">float32</span>, <span class="type">float64</span></span><br><span class="line"><span class="type">string</span></span><br><span class="line"><span class="type">complex64</span>, <span class="type">complex128</span></span><br><span class="line">array    -- 固定长度的数组</span><br></pre></td></tr></table></figure><h3 id="引用类型：-指针类型"><a href="#引用类型：-指针类型" class="headerlink" title="引用类型：(指针类型)"></a>引用类型：(指针类型)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice   -- 序列数组(最常用)</span><br><span class="line"><span class="keyword">map</span>     -- 映射</span><br><span class="line"><span class="keyword">chan</span>    -- 管道</span><br></pre></td></tr></table></figure><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span>          -- 用来追加元素到数组、slice中,返回修改后的数组、slice</span><br><span class="line"><span class="built_in">close</span>           -- 主要用来关闭channel</span><br><span class="line"><span class="built_in">delete</span>            -- 从<span class="keyword">map</span>中删除key对应的value</span><br><span class="line"><span class="built_in">panic</span>            -- 停止常规的goroutine  （<span class="built_in">panic</span>和<span class="built_in">recover</span>：用来做错误处理）</span><br><span class="line"><span class="built_in">recover</span>         -- 允许程序定义goroutine的<span class="built_in">panic</span>动作</span><br><span class="line"><span class="built_in">imag</span>            -- 返回<span class="built_in">complex</span>的实部   （<span class="built_in">complex</span>、<span class="built_in">real</span> <span class="built_in">imag</span>：用于创建和操作复数）</span><br><span class="line"><span class="built_in">real</span>            -- 返回<span class="built_in">complex</span>的虚部</span><br><span class="line"><span class="built_in">make</span>            -- 用来分配内存，返回Type本身(只能应用于slice, <span class="keyword">map</span>, channel)</span><br><span class="line"><span class="built_in">new</span>                -- 用来分配内存，主要用来分配值类型，比如<span class="type">int</span>、<span class="keyword">struct</span>。返回指向Type的指针</span><br><span class="line"><span class="built_in">cap</span>                -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 <span class="keyword">map</span>）</span><br><span class="line"><span class="built_in">copy</span>            -- 用于复制和连接slice，返回复制的数目</span><br><span class="line"><span class="built_in">len</span>                -- 来求长度，比如<span class="type">string</span>、array、slice、<span class="keyword">map</span>、channel ，返回长度</span><br><span class="line"><span class="built_in">print</span>、<span class="built_in">println</span>     -- 底层打印函数，在部署环境中建议使用 fmt 包</span><br></pre></td></tr></table></figure><h2 id="内置接口error"><a href="#内置接口error" class="headerlink" title="内置接口error"></a>内置接口error</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123; <span class="comment">//只要实现了Error()函数，返回值为String的都实现了err接口</span></span><br><span class="line"></span><br><span class="line">        Error()    String</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Init-函数和-main-函数"><a href="#2-Init-函数和-main-函数" class="headerlink" title="2. Init 函数和 main 函数"></a>2. Init 函数和 main 函数</h1><h2 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h2><p>go语言中<code>init</code>函数用于包<code>(package)</code>的初始化，该函数是go语言的一个重要特性。</p><p>有下面的特征：</p><ol><li><p>init 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</p></li><li><p>每个包可以拥有多个 init 函数</p></li><li><p>包的每个源文件也可以拥有多个 init 函数</p></li><li><p>同一个包中多个 init 函数的执行顺序 go 语言没有明确的定义(说明)</p></li><li><p>不同包的 init 函数按照包导入的依赖关系决定该初始化函数的执行顺序</p></li><li><p>init 函数不能被其他函数调用，而是在 main 函数执行之前，自动被调用</p></li></ol><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Go语言程序的默认入口函数(主函数)：func main()</span><br><span class="line">函数体用｛｝一对括号包裹。</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    //函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="init函数和main函数的异同"><a href="#init函数和main函数的异同" class="headerlink" title="init函数和main函数的异同"></a>init函数和main函数的异同</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">    两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。</span><br><span class="line">不同点：</span><br><span class="line">    init可以应用于任意包中，且可以重复定义多个。</span><br><span class="line">    main函数只能用于main包中，且只能定义一个。</span><br></pre></td></tr></table></figure><p>两个函数的执行顺序：</p><p>对同一个go文件的<code>init()</code>调用顺序是从上到下的。</p><p>对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的<code>init()</code>函数。</p><p>对于不同的<code>package</code>，如果不相互依赖的话，按照main包中”先<code>import</code>的后调用”的顺序调用其包中的<code>init()</code>，如果<code>package</code>存在依赖，则先调用最早被依赖的<code>package</code>中的<code>init()</code>，最后调用<code>main</code>函数。</p><p>如果 <code>init</code> 函数中使用了 <code>println()</code> 或者 <code>print()</code> 你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>假如你已安装了golang环境，你可以在命令行执行go命令查看相关的Go语言命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go</span></span><br><span class="line">Go is a tool for managing Go source code.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">    go command [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">    build       compile packages and dependencies</span><br><span class="line">    clean       remove object files</span><br><span class="line">    doc         show documentation for package or symbol</span><br><span class="line">    env         print Go environment information</span><br><span class="line">    bug         start a bug report</span><br><span class="line">    fix         run go tool fix on packages</span><br><span class="line">    fmt         run gofmt on package sources</span><br><span class="line">    generate    generate Go files by processing source</span><br><span class="line">    get         download and install packages and dependencies</span><br><span class="line">    install     compile and install packages and dependencies</span><br><span class="line">    list        list packages</span><br><span class="line">    run         compile and run Go program</span><br><span class="line">    test        test packages</span><br><span class="line">    tool        run specified go tool</span><br><span class="line">    version     print Go version</span><br><span class="line">    vet         run go tool vet on packages</span><br><span class="line"></span><br><span class="line">Use &quot;go help [command]&quot; for more information about a command.</span><br><span class="line"></span><br><span class="line">Additional help topics:</span><br><span class="line"></span><br><span class="line">    c           calling between Go and C</span><br><span class="line">    buildmode   description of build modes</span><br><span class="line">    filetype    file types</span><br><span class="line">    gopath      GOPATH environment variable</span><br><span class="line">    environment environment variables</span><br><span class="line">    importpath  import path syntax</span><br><span class="line">    packages    description of package lists</span><br><span class="line">    testflag    description of testing flags</span><br><span class="line">    testfunc    description of testing functions</span><br><span class="line"></span><br><span class="line">Use &quot;go help [topic]&quot; for more information about that topic.</span><br></pre></td></tr></table></figure><p>go env用于打印Go语言的环境信息。</p><p>go run命令可以编译并运行命令源码文件。</p><p>go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。</p><p>go build命令用于编译我们指定的源码文件或代码包以及它们的依赖包。</p><p>go install用于编译并安装指定的代码包及它们的依赖包。</p><p>go clean命令会删除掉执行其它命令时产生的一些文件和目录。</p><p>go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p><p>go test命令用于对Go语言编写的程序进行测试。</p><p>go list命令的作用是列出指定的代码包的信息。</p><p>go fix会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。</p><p>go vet是一个用于检查Go语言源码中静态错误的简单工具。</p><p>go tool pprof命令来交互式的访问概要文件的内容。</p><h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h3><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p><p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。</p><h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="type">bool</span></span><br></pre></td></tr></table></figure><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">string</span></span><br><span class="line">    b <span class="type">int</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">    d <span class="type">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p><p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line"><span class="keyword">var</span> sex <span class="type">int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>或者一次初始化多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, sex = <span class="string">&quot;pprof.cn&quot;</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line"><span class="keyword">var</span> sex = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 :&#x3D; 方式声明并初始化变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">10</span></span><br><span class="line">    m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">    fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线_表示，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, _ := foo()</span><br><span class="line">    _, y := foo()</span><br><span class="line">    fmt.Println(<span class="string">&quot;x=&quot;</span>, x)</span><br><span class="line">    fmt.Println(<span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在Lua等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数外的每个语句都必须以关键字开始（<span class="keyword">var</span>、<span class="keyword">const</span>、<span class="function"><span class="keyword">func</span>等）</span></span><br><span class="line"></span><br><span class="line">:=不能使用在函数外。</span><br><span class="line"></span><br><span class="line">_多用于占位，表示忽略值。</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p><p>多个常量也可以一起声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>const</code>同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面示例中，常量<code>n1、n2、n3</code>的值都是<code>100</code>。</p><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p><code>iota</code>是<code>go</code>语言的常量计数器，只能在常量的表达式中使用。 <code>iota</code>在<code>const</code>关键字出现时将被重置为<code>0</code>。<code>const</code>中每新增一行常量声明将使<code>iota</code>计数一次(<code>iota</code>可理解为<code>const</code>语句块中的行索引)。 使用<code>iota</code>能简化定义，在定义枚举时很有用。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">        n2        <span class="comment">//1</span></span><br><span class="line">        n3        <span class="comment">//2</span></span><br><span class="line">        n4        <span class="comment">//3</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="几个常见的iota示例"><a href="#几个常见的iota示例" class="headerlink" title="几个常见的iota示例:"></a>几个常见的iota示例:</h3><p>使用_跳过某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">        n2        <span class="comment">//1</span></span><br><span class="line">        _</span><br><span class="line">        n4        <span class="comment">//3</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><code>iota</code>声明中间插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">        n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">        n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">        n4        <span class="comment">//3</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将<code>1</code>的二进制表示向左移<code>10</code>位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的<code>1024</code>。同理<code>2&lt;&lt;2</code>表示将<code>2</code>的二进制表示向左移<code>2</code>位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的<code>8</code>。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        _  = <span class="literal">iota</span></span><br><span class="line">        KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">        MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">        GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">        TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">        PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>多个<code>iota</code>定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2</span></span><br><span class="line">        c, d                      <span class="comment">//2,3</span></span><br><span class="line">        e, f                      <span class="comment">//3,4</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="基本类型介绍"><a href="#基本类型介绍" class="headerlink" title="基本类型介绍"></a>基本类型介绍</h2><p>Golang 更明确的数字类型命名，支持 Unicode，支持常用数据结构。</p><table><thead><tr><th>类型</th><th>长度(字节)</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>false</td><td></td></tr><tr><td>byte</td><td>1</td><td>0</td><td>uint8</td></tr><tr><td>rune</td><td>4</td><td>0</td><td>Unicode Code Point, int32</td></tr><tr><td>int, uint</td><td>4或8</td><td>0</td><td>32 或 64 位</td></tr><tr><td>int8, uint8</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255，byte是uint8 的别名</td></tr><tr><td>int16, uint16</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32, uint32</td><td>4</td><td>0</td><td>-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td></tr><tr><td>int64, uint64</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>4</td><td>0.0</td><td></td></tr><tr><td>float64</td><td>8</td><td>0.0</td><td></td></tr><tr><td>complex64</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>4或8</td><td></td><td>以存储指针的 uint32 或 uint64 整数</td></tr><tr><td>array</td><td></td><td></td><td>值类型</td></tr><tr><td>struct</td><td></td><td></td><td>值类型</td></tr><tr><td>string</td><td></td><td>“”</td><td>UTF-8 字符串</td></tr><tr><td>slice</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>map</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>channel</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>interface</td><td></td><td>nil</td><td>接口</td></tr><tr><td>function</td><td></td><td>nil</td><td>函数</td></tr></tbody></table><p>支持八进制、 六进制，以及科学记数法。标准库 math 定义了各数字类型取值范围。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c, d := <span class="number">071</span>, <span class="number">0x1F</span>, <span class="number">1e9</span>, math.MinInt16</span><br></pre></td></tr></table></figure><p>空指针值 nil，而非C&#x2F;C++ NULL。</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>整型分为以下两个大类： 按长度分为：<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code>对应的无符号整型：<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code></p><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为<code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p><code>complex64</code>和<code>complex128</code></p><p>复数有实部和虚部，<code>complex64</code>的实部和虚部为32位，<code>complex128</code>的实部和虚部为64位。</p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line"></span><br><span class="line">布尔类型变量的默认值为<span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line">Go 语言中不允许将整型强制转换为布尔型.</span><br><span class="line"></span><br><span class="line">布尔型无法参与数值运算，也无法与其他类型进行转换。</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型<code>（int、bool、float32、float64 等）</code>一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(“)中的内容，可以在Go语言的源码中直接添加非<code>ASCII</code>码字符，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;你好&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转义</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>|反斜杠</td><td></td></tr></tbody></table><p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;str := \&quot;c:\\pprof\\main.exe\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.Contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix,strings.HasSuffix</td><td>前缀&#x2F;后缀判断</td></tr><tr><td>strings.Index(),strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join操作</td></tr></tbody></table><h3 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h3><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a := <span class="string">&#x27;中&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b := <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8</span>类型，或者叫 <span class="type">byte</span> 型，代表了ASCII码的一个字符。</span><br><span class="line"></span><br><span class="line"><span class="type">rune</span>类型，代表一个 UTF<span class="number">-8</span>字符。</span><br></pre></td></tr></table></figure><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。 Go 使用了特殊的 <code>rune</code> 类型来处理 <code>Unicode</code>，让基于 <code>Unicode</code>的文本处理更为方便，也可以使用 <code>byte</code> 型进行默认字符串处理，性能和扩展性都有照顾</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalString</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;pprof.cn博客&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, s[i], s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, r, r)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">112</span>(p) <span class="number">112</span>(p) <span class="number">114</span>(r) <span class="number">111</span>(o) <span class="number">102</span>(f) <span class="number">46</span>(.) <span class="number">99</span>(c) <span class="number">110</span>(n) <span class="number">229</span>(å) <span class="number">141</span>() <span class="number">154</span>() <span class="number">229</span>(å) <span class="number">174</span>(®) <span class="number">162</span>(¢)</span><br><span class="line"><span class="number">112</span>(p) <span class="number">112</span>(p) <span class="number">114</span>(r) <span class="number">111</span>(o) <span class="number">102</span>(f) <span class="number">46</span>(.) <span class="number">99</span>(c) <span class="number">110</span>(n) <span class="number">21338</span>(博) <span class="number">23458</span>(客)</span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由<code>3~4</code>个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p><p>字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune或[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="comment">// 强制类型转换</span></span><br><span class="line">    byteS1 := []<span class="type">byte</span>(s1)</span><br><span class="line">    byteS1[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">    s2 := <span class="string">&quot;博客&quot;</span></span><br><span class="line">    runeS2 := []<span class="type">rune</span>(s2)</span><br><span class="line">    runeS2[<span class="number">0</span>] = <span class="string">&#x27;狗&#x27;</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p><p>强制类型转换的基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p><p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line">    <span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">    c = <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(a*a + b*b)))</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h1><p>Golang Array和以往认知的数组有很大不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 数组：是同一种数据类型的固定长度的序列。</span><br><span class="line"><span class="number">2.</span> 数组定义：<span class="keyword">var</span> a [<span class="built_in">len</span>]<span class="type">int</span>，比如：<span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span>，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。</span><br><span class="line"><span class="number">3.</span> 长度是数组类型的一部分，因此，<span class="keyword">var</span> a[<span class="number">5</span>] <span class="type">int</span>和<span class="keyword">var</span> a[<span class="number">10</span>]<span class="type">int</span>是不同的类型。</span><br><span class="line"><span class="number">4.</span> 数组可以通过下标进行访问，下标是从<span class="number">0</span>开始，最后一个元素下标是：<span class="built_in">len</span><span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span> 访问越界，如果下标在数组合法范围之外，则触发访问越界，会<span class="built_in">panic</span></span><br><span class="line"><span class="number">6.</span> 数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。</span><br><span class="line"><span class="number">7.</span>支持 <span class="string">&quot;==&quot;</span>、<span class="string">&quot;!=&quot;</span> 操作符，因为内存总是被初始化过的。</span><br><span class="line"><span class="number">8.</span>指针数组 [n]*T，数组指针 *[n]T。</span><br></pre></td></tr></table></figure><h3 id="数组初始化："><a href="#数组初始化：" class="headerlink" title="数组初始化："></a>数组初始化：</h3><h4 id="一维数组："><a href="#一维数组：" class="headerlink" title="一维数组："></a>一维数组：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">全局：</span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">var</span> str = [<span class="number">5</span>]<span class="type">string</span>&#123;<span class="number">3</span>: <span class="string">&quot;hello world&quot;</span>, <span class="number">4</span>: <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line">局部：</span><br><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;           <span class="comment">// 未初始化元素值为 0。</span></span><br><span class="line">b := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;   <span class="comment">// 通过初始化值确定数组长度。</span></span><br><span class="line">c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">100</span>, <span class="number">4</span>: <span class="number">200</span>&#125; <span class="comment">// 使用索引号初始化元素。</span></span><br><span class="line">d := [...]<span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">uint8</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;user1&quot;</span>, <span class="number">10</span>&#125;, <span class="comment">// 可省略元素类型。</span></span><br><span class="line">    &#123;<span class="string">&quot;user2&quot;</span>, <span class="number">20</span>&#125;, <span class="comment">// 别忘了最后一行的逗号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">var</span> str = [<span class="number">5</span>]<span class="type">string</span>&#123;<span class="number">3</span>: <span class="string">&quot;hello world&quot;</span>, <span class="number">4</span>: <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;           <span class="comment">// 未初始化元素值为 0。</span></span><br><span class="line">    b := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;   <span class="comment">// 通过初始化值确定数组长度。</span></span><br><span class="line">    c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">100</span>, <span class="number">4</span>: <span class="number">200</span>&#125; <span class="comment">// 使用引号初始化元素。</span></span><br><span class="line">    d := [...]<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="type">string</span></span><br><span class="line">        age  <span class="type">uint8</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;user1&quot;</span>, <span class="number">10</span>&#125;, <span class="comment">// 可省略元素类型。</span></span><br><span class="line">        &#123;<span class="string">&quot;user2&quot;</span>, <span class="number">20</span>&#125;, <span class="comment">// 别忘了最后一行的逗号。</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(arr0, arr1, arr2, str)</span><br><span class="line">    fmt.Println(a, b, c, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span>] [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>] [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] [   hello world tom]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>] [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>] [<span class="number">0</span> <span class="number">0</span> <span class="number">100</span> <span class="number">0</span> <span class="number">200</span>] [&#123;user1 <span class="number">10</span>&#125; &#123;user2 <span class="number">20</span>&#125;]</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全局</span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">5</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> = [...][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;</span><br><span class="line">局部：</span><br><span class="line">a := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">b := [...][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125; <span class="comment">// 第 2 纬度不能用 &quot;...&quot;。</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">5</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> = [...][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">    b := [...][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125; <span class="comment">// 第 2 纬度不能用 &quot;...&quot;。</span></span><br><span class="line">    fmt.Println(arr0, arr1)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]] [[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]] [[<span class="number">1</span> <span class="number">1</span>] [<span class="number">2</span> <span class="number">2</span>] [<span class="number">3</span> <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>值拷贝行为会造成性能问题，通常会建议使用 slice，或数组指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x [2]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x: %p\n&quot;</span>, &amp;x)</span><br><span class="line">    x[<span class="number">1</span>] = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a: %p\n&quot;</span>, &amp;a)</span><br><span class="line"></span><br><span class="line">    test(a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: <span class="number">0xc42007c010</span></span><br><span class="line">x: <span class="number">0xc42007c030</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>内置函数 len 和 cap 都返回数组长度 (元素数量)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="built_in">len</span>(a), <span class="built_in">cap</span>(a)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="多维数组遍历："><a href="#多维数组遍历：" class="headerlink" title="多维数组遍历："></a>多维数组遍历：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> f [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> = [...][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k1, v1 := <span class="keyword">range</span> f &#123;</span><br><span class="line">        <span class="keyword">for</span> k2, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;(%d,%d)=%d &quot;</span>, k1, k2, v2)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>,<span class="number">0</span>)=<span class="number">1</span> (<span class="number">0</span>,<span class="number">1</span>)=<span class="number">2</span> (<span class="number">0</span>,<span class="number">2</span>)=<span class="number">3</span> </span><br><span class="line">(<span class="number">1</span>,<span class="number">0</span>)=<span class="number">7</span> (<span class="number">1</span>,<span class="number">1</span>)=<span class="number">8</span> (<span class="number">1</span>,<span class="number">2</span>)=<span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="数组拷贝和传参"><a href="#数组拷贝和传参" class="headerlink" title="数组拷贝和传参"></a>数组拷贝和传参</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArr</span><span class="params">(arr *[5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        fmt.Println(i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    printArr(&amp;arr1)</span><br><span class="line">    fmt.Println(arr1)</span><br><span class="line">    arr2 := [...]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;</span><br><span class="line">    printArr(&amp;arr2)</span><br><span class="line">    fmt.Println(arr2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-语言中的指针"><a href="#Go-语言中的指针" class="headerlink" title="Go 语言中的指针"></a>Go 语言中的指针</h2><p>Go语言中的函数传参都是值拷贝，当我们想要修改某个变量的时候，我们可以创建一个指向该变量地址的指针变量。传递数据使用指针，而无须拷贝数据。类型指针不能进行偏移和运算。Go语言中的指针操作非常简单，只需要记住两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p><h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型<code>（int、float、bool、string、array、struct）</code>都有对应的指针类型，如：<code>*int、*int64、*string</code>等。</p><p>取变量指针的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    // v的类型为T</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v:代表被取地址的变量，类型为T</span><br><span class="line">ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := 10</span><br><span class="line">    b := &amp;a</span><br><span class="line">    fmt.Printf(&quot;a:%d ptr:%p\n&quot;, a, &amp;a) // a:10 ptr:0xc00001a078</span><br><span class="line">    fmt.Printf(&quot;b:%p type:%T\n&quot;, b, b) // b:0xc00001a078 type:*int</span><br><span class="line">    fmt.Println(&amp;b)                    // 0xc00000e018</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下<code>b := &amp;a</code>的图示：</p><p><img src="https://www.topgoer.com/static/3.9/1.png" alt="指针" title="指针"></p><h3 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h3><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用<code>*</code>操作，也就是指针取值，代码如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    //指针取值</span><br><span class="line">    a := 10</span><br><span class="line">    b := &amp;a // 取变量a的地址，将指针保存到b中</span><br><span class="line">    fmt.Printf(&quot;type of b:%T\n&quot;, b)</span><br><span class="line">    c := *b // 指针取值（根据指针去内存取值）</span><br><span class="line">    fmt.Printf(&quot;type of c:%T\n&quot;, c)</span><br><span class="line">    fmt.Printf(&quot;value of c:%v\n&quot;, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type of b:*int</span><br><span class="line">type of c:int</span><br><span class="line">value of c:10</span><br></pre></td></tr></table></figure><p>总结： 取地址操作符&amp;和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：\</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</span><br><span class="line">2.指针变量的值是指针地址。</span><br><span class="line">3.对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</span><br></pre></td></tr></table></figure><p>指针传值示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func modify1(x int) &#123;</span><br><span class="line">    x = 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func modify2(x *int) &#123;</span><br><span class="line">    *x = 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a := 10</span><br><span class="line">    modify1(a)</span><br><span class="line">    fmt.Println(a) // 10</span><br><span class="line">    modify2(&amp;a)</span><br><span class="line">    fmt.Println(a) // 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><ul><li>当一个指针被定义后没有分配到任何变量时，它的值为 nil</li><li>空指针的判断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var p *string</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    fmt.Printf(&quot;p的值是%s/n&quot;, p)</span><br><span class="line">    if p != nil &#123;</span><br><span class="line">        fmt.Println(&quot;非空&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;空值&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4-new和make"><a href="#1-1-4-new和make" class="headerlink" title="1.1.4. new和make"></a>1.1.4. new和make</h3><p>我们先来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var a *int</span><br><span class="line">    *a = 100</span><br><span class="line">    fmt.Println(*a)</span><br><span class="line"></span><br><span class="line">    var b map[string]int</span><br><span class="line">    b[&quot;测试&quot;] = 100</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new是一个内置的函数，它的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func new(Type) *Type</span><br></pre></td></tr></table></figure><p>其中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Type表示类型，new函数只接受一个参数，这个参数是一个类型</span><br><span class="line">2.*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</span><br></pre></td></tr></table></figure><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    a := new(int)</span><br><span class="line">    b := new(bool)</span><br><span class="line">    fmt.Printf(&quot;%T\n&quot;, a) // *int</span><br><span class="line">    fmt.Printf(&quot;%T\n&quot;, b) // *bool</span><br><span class="line">    fmt.Println(*a)       // 0</span><br><span class="line">    fmt.Println(*b)       // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节开始的示例代码中<code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var a *int</span><br><span class="line">    a = new(int)</span><br><span class="line">    *a = 10</span><br><span class="line">    fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func make(t Type, size ...IntegerType) Type</span><br></pre></td></tr></table></figure><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p><p>本节开始的示例中<code>var b map[string]int</code>只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var b map[string]int</span><br><span class="line">    b = make(map[string]int, 10)</span><br><span class="line">    b[&quot;测试&quot;] = 100</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new与make的区别"><a href="#new与make的区别" class="headerlink" title="new与make的区别"></a>new与make的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.二者都是用来做内存分配的。</span><br><span class="line">2.make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</span><br><span class="line">3.而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</span><br></pre></td></tr></table></figure><h3 id="指针小练习"><a href="#指针小练习" class="headerlink" title="指针小练习"></a>指针小练习</h3><ul><li>程序定义一个int变量num的地址并打印</li><li>将num的地址赋给指针ptr，并通过ptr去修改num的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var a int</span><br><span class="line">    fmt.Println(&amp;a)</span><br><span class="line">    var p *int</span><br><span class="line">    p = &amp;a</span><br><span class="line">    *p = 20</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><h2 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h2><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用type关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将MyInt定义为int类型</span><br><span class="line">type MyInt int</span><br></pre></td></tr></table></figure><p>通过Type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名是Go1.9版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type TypeAlias = Type</span><br></pre></td></tr></table></figure><p>我们之前见过的rune和byte就是类型别名，他们的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type byte = uint8</span><br><span class="line">type rune = int32</span><br></pre></td></tr></table></figure><h3 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h3><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//类型定义</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">type MyInt = int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var a NewInt</span><br><span class="line">    var b MyInt</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;type of a:%T\n&quot;, a) //type of a:main.NewInt</span><br><span class="line">    fmt.Printf(&quot;type of b:%T\n&quot;, b) //type of b:int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</p><h2 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h2><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。</p><p>Go语言中通过struct来实现面向对象。</p><h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 类型名 struct &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.类型名：标识自定义结构体的名称，在同一个包内不能重复。</span><br><span class="line">2.字段名：表示结构体字段名。结构体中的字段名必须唯一。</span><br><span class="line">3.字段类型：表示结构体字段的具体类型。</span><br></pre></td></tr></table></figure><p>举个例子，我们定义一个Person（人）结构体，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    city string</span><br><span class="line">    age  int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type person1 struct &#123;</span><br><span class="line">    name, city string</span><br><span class="line">    age        int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。</p><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p><h3 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h3><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    city string</span><br><span class="line">    age  int8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var p1 person</span><br><span class="line">    p1.name = &quot;pprof.cn&quot;</span><br><span class="line">    p1.city = &quot;北京&quot;</span><br><span class="line">    p1.age = 18</span><br><span class="line">    fmt.Printf(&quot;p1=%v\n&quot;, p1)  //p1=&#123;pprof.cn 北京 18&#125;</span><br><span class="line">    fmt.Printf(&quot;p1=%#v\n&quot;, p1) //p1=main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。</p><h2 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h2><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var user struct&#123;Name string; Age int&#125;</span><br><span class="line">    user.Name = &quot;pprof.cn&quot;</span><br><span class="line">    user.Age = 18</span><br><span class="line">    fmt.Printf(&quot;%#v\n&quot;, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h3><p>我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p2 = new(person)</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, p2)     //*main.person</span><br><span class="line">fmt.Printf(&quot;p2=%#v\n&quot;, p2) //p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出p2是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p2 = new(person)</span><br><span class="line">p2.name = &quot;测试&quot;</span><br><span class="line">p2.age = 18</span><br><span class="line">p2.city = &quot;北京&quot;</span><br><span class="line">fmt.Printf(&quot;p2=%#v\n&quot;, p2) //p2=&amp;main.person&#123;name:&quot;测试&quot;, city:&quot;北京&quot;, age:18&#125;</span><br></pre></td></tr></table></figure><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, p3)     //*main.person</span><br><span class="line">fmt.Printf(&quot;p3=%#v\n&quot;, p3) //p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br><span class="line">p3.name = &quot;博客&quot;</span><br><span class="line">p3.age = 30</span><br><span class="line">p3.city = &quot;成都&quot;</span><br><span class="line">fmt.Printf(&quot;p3=%#v\n&quot;, p3) //p3=&amp;main.person&#123;name:&quot;博客&quot;, city:&quot;成都&quot;, age:30&#125;</span><br></pre></td></tr></table></figure><p>p3.name &#x3D; “博客”其实在底层是(*p3).name &#x3D; “博客”，这是Go语言帮我们实现的语法糖。</p><h3 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    city string</span><br><span class="line">    age  int8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var p4 person</span><br><span class="line">    fmt.Printf(&quot;p4=%#v\n&quot;, p4) //p4=main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">    name: &quot;pprof.cn&quot;,</span><br><span class="line">    city: &quot;北京&quot;,</span><br><span class="line">    age:  18,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p5=%#v\n&quot;, p5) //p5=main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">    name: &quot;pprof.cn&quot;,</span><br><span class="line">    city: &quot;北京&quot;,</span><br><span class="line">    age:  18,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p6=%#v\n&quot;, p6) //p6=&amp;main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">    city: &quot;北京&quot;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p7=%#v\n&quot;, p7) //p7=&amp;main.person&#123;name:&quot;&quot;, city:&quot;北京&quot;, age:0&#125;</span><br></pre></td></tr></table></figure><h3 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">    &quot;pprof.cn&quot;,</span><br><span class="line">    &quot;北京&quot;,</span><br><span class="line">    18,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p8=%#v\n&quot;, p8) //p8=&amp;main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.必须初始化结构体的所有字段。</span><br><span class="line">2.初始值的填充顺序必须与字段在结构体中的声明顺序一致。</span><br><span class="line">3.该方式不能和键值初始化方式混用。</span><br></pre></td></tr></table></figure><h3 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type test struct &#123;</span><br><span class="line">    a int8</span><br><span class="line">    b int8</span><br><span class="line">    c int8</span><br><span class="line">    d int8</span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line">    1, 2, 3, 4,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;n.a %p\n&quot;, &amp;n.a)</span><br><span class="line">fmt.Printf(&quot;n.b %p\n&quot;, &amp;n.b)</span><br><span class="line">fmt.Printf(&quot;n.c %p\n&quot;, &amp;n.c)</span><br><span class="line">fmt.Printf(&quot;n.d %p\n&quot;, &amp;n.d)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type student struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m := make(map[string]*student)</span><br><span class="line">    stus := []student&#123;</span><br><span class="line">        &#123;name: &quot;pprof.cn&quot;, age: 18&#125;,</span><br><span class="line">        &#123;name: &quot;测试&quot;, age: 23&#125;,</span><br><span class="line">        &#123;name: &quot;博客&quot;, age: 28&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for _, stu := range stus &#123;</span><br><span class="line">        m[stu.name] = &amp;stu</span><br><span class="line">    &#125;</span><br><span class="line">    for k, v := range m &#123;</span><br><span class="line">        fmt.Println(k, &quot;=&gt;&quot;, v.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func newPerson(name, city string, age int8) *person &#123;</span><br><span class="line">    return &amp;person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        city: city,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 := newPerson(&quot;pprof.cn&quot;, &quot;测试&quot;, 90)</span><br><span class="line">fmt.Printf(&quot;%#v\n&quot;, p9)</span><br></pre></td></tr></table></figure><h3 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h3><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p><p>方法的定义格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</span><br><span class="line">2.接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</span><br><span class="line">3.方法名、参数列表、返回参数：具体格式与函数定义相同。</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Person 结构体</span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//NewPerson 构造函数</span><br><span class="line">func NewPerson(name string, age int8) *Person &#123;</span><br><span class="line">    return &amp;Person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Dream Person做梦的方法</span><br><span class="line">func (p Person) Dream() &#123;</span><br><span class="line">    fmt.Printf(&quot;%s的梦想是学好Go语言！\n&quot;, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p1 := NewPerson(&quot;测试&quot;, 25)</span><br><span class="line">    p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SetAge 设置p的年龄</span><br><span class="line">// 使用指针接收者</span><br><span class="line">func (p *Person) SetAge(newAge int8) &#123;</span><br><span class="line">    p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    p1 := NewPerson(&quot;测试&quot;, 25)</span><br><span class="line">    fmt.Println(p1.age) // 25</span><br><span class="line">    p1.SetAge(30)</span><br><span class="line">    fmt.Println(p1.age) // 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SetAge2 设置p的年龄</span><br><span class="line">// 使用值接收者</span><br><span class="line">func (p Person) SetAge2(newAge int8) &#123;</span><br><span class="line">    p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p1 := NewPerson(&quot;测试&quot;, 25)</span><br><span class="line">    p1.Dream()</span><br><span class="line">    fmt.Println(p1.age) // 25</span><br><span class="line">    p1.SetAge2(30) // (*p1).SetAge2(30)</span><br><span class="line">    fmt.Println(p1.age) // 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.需要修改接收者中的值</span><br><span class="line">2.接收者是拷贝代价比较大的大对象</span><br><span class="line">3.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</span><br></pre></td></tr></table></figure><h3 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h3><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//MyInt 将int定义为自定义MyInt类型</span><br><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">//SayHello 为MyInt添加一个SayHello的方法</span><br><span class="line">func (m MyInt) SayHello() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello, 我是一个int。&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var m1 MyInt</span><br><span class="line">    m1.SayHello() //Hello, 我是一个int。</span><br><span class="line">    m1 = 100</span><br><span class="line">    fmt.Printf(&quot;%#v  %T\n&quot;, m1, m1) //100  main.MyInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h3 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h3><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Person 结构体Person类型</span><br><span class="line">type Person struct &#123;</span><br><span class="line">    string</span><br><span class="line">    int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p1 := Person&#123;</span><br><span class="line">        &quot;pprof.cn&quot;,</span><br><span class="line">        18,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%#v\n&quot;, p1)        //main.Person&#123;string:&quot;pprof.cn&quot;, int:18&#125;</span><br><span class="line">    fmt.Println(p1.string, p1.int) //pprof.cn 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h3><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Address 地址结构体</span><br><span class="line">type Address struct &#123;</span><br><span class="line">    Province string</span><br><span class="line">    City     string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//User 用户结构体</span><br><span class="line">type User struct &#123;</span><br><span class="line">    Name    string</span><br><span class="line">    Gender  string</span><br><span class="line">    Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    user1 := User&#123;</span><br><span class="line">        Name:   &quot;pprof&quot;,</span><br><span class="line">        Gender: &quot;女&quot;,</span><br><span class="line">        Address: Address&#123;</span><br><span class="line">            Province: &quot;黑龙江&quot;,</span><br><span class="line">            City:     &quot;哈尔滨&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;user1=%#v\n&quot;, user1)//user1=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;哈尔滨&quot;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a>嵌套匿名结构体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Address 地址结构体</span><br><span class="line">type Address struct &#123;</span><br><span class="line">    Province string</span><br><span class="line">    City     string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//User 用户结构体</span><br><span class="line">type User struct &#123;</span><br><span class="line">    Name    string</span><br><span class="line">    Gender  string</span><br><span class="line">    Address //匿名结构体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var user2 User</span><br><span class="line">    user2.Name = &quot;pprof&quot;</span><br><span class="line">    user2.Gender = &quot;女&quot;</span><br><span class="line">    user2.Address.Province = &quot;黑龙江&quot;    //通过匿名结构体.字段名访问</span><br><span class="line">    user2.City = &quot;哈尔滨&quot;                //直接访问匿名结构体的字段名</span><br><span class="line">    fmt.Printf(&quot;user2=%#v\n&quot;, user2) //user2=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;哈尔滨&quot;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p><h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Address 地址结构体</span><br><span class="line">type Address struct &#123;</span><br><span class="line">    Province   string</span><br><span class="line">    City       string</span><br><span class="line">    CreateTime string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Email 邮箱结构体</span><br><span class="line">type Email struct &#123;</span><br><span class="line">    Account    string</span><br><span class="line">    CreateTime string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//User 用户结构体</span><br><span class="line">type User struct &#123;</span><br><span class="line">    Name   string</span><br><span class="line">    Gender string</span><br><span class="line">    Address</span><br><span class="line">    Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var user3 User</span><br><span class="line">    user3.Name = &quot;pprof&quot;</span><br><span class="line">    user3.Gender = &quot;女&quot;</span><br><span class="line">    // user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</span><br><span class="line">    user3.Address.CreateTime = &quot;2000&quot; //指定Address结构体中的CreateTime</span><br><span class="line">    user3.Email.CreateTime = &quot;2000&quot;   //指定Email结构体中的CreateTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h3><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Animal 动物</span><br><span class="line">type Animal struct &#123;</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Animal) move() &#123;</span><br><span class="line">    fmt.Printf(&quot;%s会动！\n&quot;, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Dog 狗</span><br><span class="line">type Dog struct &#123;</span><br><span class="line">    Feet    int8</span><br><span class="line">    *Animal //通过嵌套匿名结构体实现继承</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Dog) wang() &#123;</span><br><span class="line">    fmt.Printf(&quot;%s会汪汪汪~\n&quot;, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    d1 := &amp;Dog&#123;</span><br><span class="line">        Feet: 4,</span><br><span class="line">        Animal: &amp;Animal&#123; //注意嵌套的是结构体指针</span><br><span class="line">            name: &quot;乐乐&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    d1.wang() //乐乐会汪汪汪~</span><br><span class="line">    d1.move() //乐乐会动！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h3><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h3 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键&#x2F;值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//Student 学生</span><br><span class="line">type Student struct &#123;</span><br><span class="line">    ID     int</span><br><span class="line">    Gender string</span><br><span class="line">    Name   string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Class 班级</span><br><span class="line">type Class struct &#123;</span><br><span class="line">    Title    string</span><br><span class="line">    Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    c := &amp;Class&#123;</span><br><span class="line">        Title:    &quot;101&quot;,</span><br><span class="line">        Students: make([]*Student, 0, 200),</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        stu := &amp;Student&#123;</span><br><span class="line">            Name:   fmt.Sprintf(&quot;stu%02d&quot;, i),</span><br><span class="line">            Gender: &quot;男&quot;,</span><br><span class="line">            ID:     i,</span><br><span class="line">        &#125;</span><br><span class="line">        c.Students = append(c.Students, stu)</span><br><span class="line">    &#125;</span><br><span class="line">    //JSON序列化：结构体--&gt;JSON格式的字符串</span><br><span class="line">    data, err := json.Marshal(c)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;json marshal failed&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;json:%s\n&quot;, data)</span><br><span class="line">    //JSON反序列化：JSON格式的字符串--&gt;结构体</span><br><span class="line">    str := `&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;`</span><br><span class="line">    c1 := &amp;Class&#123;&#125;</span><br><span class="line">    err = json.Unmarshal([]byte(str), c1)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;json unmarshal failed!&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%#v\n&quot;, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h3><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。</p><p>Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span><br></pre></td></tr></table></figure><p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p><p>例如我们为Student结构体的每个字段定义json序列化时使用的Tag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Student 学生</span><br><span class="line">type Student struct &#123;</span><br><span class="line">    ID     int    `json:&quot;id&quot;` //通过指定tag实现json序列化该字段时的key</span><br><span class="line">    Gender string //json序列化是默认使用字段名作为key</span><br><span class="line">    name   string //私有不能被json包访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    s1 := Student&#123;</span><br><span class="line">        ID:     1,</span><br><span class="line">        Gender: &quot;女&quot;,</span><br><span class="line">        name:   &quot;pprof&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    data, err := json.Marshal(s1)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;json marshal failed!&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;json str:%s\n&quot;, data) //json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;女&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小练习："><a href="#小练习：" class="headerlink" title="小练习："></a>小练习：</h3><p>猜一下下列代码运行的结果是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type student struct &#123;</span><br><span class="line">    id   int</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func demo(ce []student) &#123;</span><br><span class="line">    //切片是引用传递，是可以改变值的</span><br><span class="line">    ce[1].age = 999</span><br><span class="line">    // ce = append(ce, student&#123;3, &quot;xiaowang&quot;, 56&#125;)</span><br><span class="line">    // return ce</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var ce []student  //定义一个切片类型的结构体</span><br><span class="line">    ce = []student&#123;</span><br><span class="line">        student&#123;1, &quot;xiaoming&quot;, 22&#125;,</span><br><span class="line">        student&#123;2, &quot;xiaozhang&quot;, 33&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">    demo(ce)</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除map类型的结构体"><a href="#删除map类型的结构体" class="headerlink" title="删除map类型的结构体"></a>删除map类型的结构体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type student struct &#123;</span><br><span class="line">    id   int</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ce := make(map[int]student)</span><br><span class="line">    ce[1] = student&#123;1, &quot;xiaolizi&quot;, 22&#125;</span><br><span class="line">    ce[2] = student&#123;2, &quot;wang&quot;, 23&#125;</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">    delete(ce, 2)</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-内置类型和函数&quot;&gt;&lt;a href=&quot;#Golang-内置类型和函数&quot; class=&quot;headerlink&quot; title=&quot;Golang 内置类型和函数&quot;&gt;&lt;/a&gt;Golang 内置类型和函数&lt;/h1&gt;&lt;h2 id=&quot;内置类型&quot;&gt;&lt;a href=&quot;#内</summary>
      
    
    
    
    <category term="计算机语言知识库" scheme="https://coding.lilming.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>高校生均成本核算系统</title>
    <link href="https://coding.lilming.top/2023/08/29/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/%E9%AB%98%E6%A0%A1%E7%94%9F%E5%9D%87%E6%88%90%E6%9C%AC%E6%A0%B8%E7%AE%97%E7%B3%BB%E7%BB%9F/"/>
    <id>https://coding.lilming.top/2023/08/29/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/%E9%AB%98%E6%A0%A1%E7%94%9F%E5%9D%87%E6%88%90%E6%9C%AC%E6%A0%B8%E7%AE%97%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-08-29T15:09:00.000Z</published>
    <updated>2023-09-14T08:27:50.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="遇到的问题和自己的思考🤔"><a href="#遇到的问题和自己的思考🤔" class="headerlink" title="遇到的问题和自己的思考🤔"></a>遇到的问题和自己的思考🤔</h1><ol><li>学科是在成本中心表中还是在学科专业目录表中？虽然学科专业目录表带了学科二字但我觉得应该是在成本中心表中，因为学院到学科是存在分配路径的，也涉及到了成本动因，应该也属于成本中心。那么学科专业目录树结构也就没有意义了，也要更名为专业目录表。学科是指下面的学科：<br> <img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230830220841.png"></li><li>如果第一个想法是对的话，学科专业目录中的成本中心 id 就应该有多个成本中心 id，用逗号分隔。在成本动因采集的自动取数中，动因量是依据填入的成本中心 id 自动读表计算得到的，假设是读取在校学生人数表，在校学生人数表只有专业 ID，就要先从学科专业目录表中选取对应成本中心的 id 值，然而学科也算成本中心，会计学的成本中心就是管理学和会计学院。</li><li>马克思学院、外国语学院和理学院有基础教学功能的学院要区分公共课与专业课，按照课时比例，在本学院和全校范围进行分摊。然而动因采集表只有成本中心 ID，动因量这两个关键字段，没办法区分是哪个学院开始的公共课，那么是否是通过设置多个成本动因来解决的，比如：理学院授课时长、外国语学院授课时长、理学院授课时长。其次，开课明细表缺少成本中心 id，比如概率论由理学院开课，成本中心就是是理学院，并且要有特殊的取数规则，以理学院授课时长举例：在成本动因自动取数的过程中，要选取开课明细表中开课学院是理学院的，这与其他的成本动因取数方式不同，比如学生人数就直接选取人数就好了，不需要额外筛选；我的想法是在成本动因中的计算公式中使用 sql 注入，添加一个 where 筛选条件，比如 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> cost_center_id <span class="operator">=</span> <span class="string">&#x27;XXX&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>家庭补助支出里的 <code>专业</code> 和 <code>学科</code> 字段的 ID 还是字符串？</li><li>理学院直接分配到二级学院会形成环，整个数据结构会变成图而不是树</li><li>理学院、马克思学院与外国语学院之间存在双向分配关系</li><li>除不尽的小数如何处理</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;遇到的问题和自己的思考🤔&quot;&gt;&lt;a href=&quot;#遇到的问题和自己的思考🤔&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题和自己的思考🤔&quot;&gt;&lt;/a&gt;遇到的问题和自己的思考🤔&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;学科是在成本中心表中还是在学科专业目录表</summary>
      
    
    
    
    <category term="项目开发" scheme="https://coding.lilming.top/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>orginone功能开发——应用开发手册</title>
    <link href="https://coding.lilming.top/2023/08/07/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/orginone%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
    <id>https://coding.lilming.top/2023/08/07/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/orginone%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</id>
    <published>2023-08-07T13:21:00.000Z</published>
    <updated>2023-09-14T08:23:36.026Z</updated>
    
    <content type="html"><![CDATA[<p>本教程将引导你逐步实现一个简单的大型仪器预约应用，实现新增大型仪器以及对仪器进行预约申请。在此过程中你会学习到基于 orginone 平台进行应用开发的基本过程，同时又助于让你对 orginone 平台有更深入的理解。</p><h1 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h1><p>所谓 <code>属性</code> 是指表单中各个字段的标签，用于标识表单中每个字段的类型和名称。一个 <code>属性</code> 可以添加到多个表单中，为表单添加一项字段，而表单中的字段被称为 <code>特性</code>，若将 <code>属性</code> 比作父母，则 <code>特性</code> 就好比孩子。</p><p>在该应用中我们需要两个表单，分别是 <code>仪器列表</code> 和 <code>预约申请</code>，接下来我们为这两个表单创建属性。</p><p>为了方便创建应用，我们先在个人页面中创建一个单位，命名为 <code>功能示范</code>，在该单位下创建目录 <code>大型仪器共享</code>，在该目录下创建目录 <code>属性</code>，用来存放该应用下的所有属性。</p><p><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230808194453.png"></p><p>右键目录空白处，依次点击 <code>新建更多&gt;新建属性</code>。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230808194540.png"></p><p>在弹出的表单中填写我们的第一个属性：<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230808140934.png"></p><p>创建好了仪器的名称属性后，我们再一一创建单位、分类、价值属性，单位和分类我们选择 <code>描述型</code>，价值我们选择 <code>数值型</code>。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230808141728.png"></p><p>设置好 <code>仪器列表</code> 的属性后，我们设置 <code>预约申请</code> 的属性。<code>预约申请</code> 的属性只需开始时间和结束时间，添加开始时间和结束时间即可，这两个属性的类型都设置为 <code>时间型</code>。</p><p><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230808195446.png"></p><h1 id="设置分类"><a href="#设置分类" class="headerlink" title="设置分类"></a>设置分类</h1><p>如果一些属性其值是固定的几个之一，我们可以建立 <code>分类</code>，来限定属性值，方便录入和统计，当然这一步不是必要的，不设立分类也可以实现本功能如果没有这方面的需求可以跳过。在要建立分类的属性的同级目录下，创建分类。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814223540.png"></p><p>之后点击分类，录入分类项目：医疗仪器、工业仪器、办公设备。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814223620.png"></p><p>设置好分类之后，回到目录右击仪器分类，点击更新信息。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814224007.png"></p><p>将属性类型改为 <code>分类型</code>，在选择分类中选择刚刚创建好分类。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814224136.png"></p><h1 id="创建实体表单"><a href="#创建实体表单" class="headerlink" title="创建实体表单"></a>创建实体表单</h1><p><code>实体表单</code> 对应着的是实际存在的事物，而与之相对的 <code>事项表单</code> 是抽象的事物，例如在该应用中大型仪器应当使用实体表单，而预约申请则应当使用事项表单。</p><p>我们在 <code>大型仪器共享</code> 目录下再创建一个目录 <code>实体表单</code>，在该目录下右击空白处创建实体表单。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814224744.png"></p><p>在表单的配置面板点击 <code>新增特性</code>，依次点击对应的目录，找到要新增的特性，这里我们选择：仪器名称、单位、仪器分类、仪器价值。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814225148.png"></p><p><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814225254.png"></p><h1 id="创建事项表单"><a href="#创建事项表单" class="headerlink" title="创建事项表单"></a>创建事项表单</h1><p>与实体表单类似，我们同样在先创建一个事项目录，在目录下新建事项表单，并将 开始时间以及结束时间作为表单特性。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815135509.png"></p><h1 id="创建办事"><a href="#创建办事" class="headerlink" title="创建办事"></a>创建办事</h1><p>办事只能存在于应用下，我们先在空白处右击，点击 <code>新建更多&gt;新建应用</code>，命名为大型仪器共享<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815110655.png"></p><p>双击应用后进入应用，再右击空白处，新建办事。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815110806.png"></p><p>将办事命名为 <code>仪器预约</code>，其余配置如下图所示：<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815133907.png"></p><p>双击办事，进入办事设计页面，在起始节点处关联子表，将 <code>预约申请</code> 以及 <code>大型仪器</code> 表单设置为子表：<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815134046.png"></p><p>在点击起始节点下方的加号，添加审批节点，在审批节点处添加审批对象管理员。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815134206.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815134218.png"></p><h1 id="发起办事"><a href="#发起办事" class="headerlink" title="发起办事"></a>发起办事</h1><p>自此，一个简单的应用示例就完成了，接下来我们来发起办事。先切换到 <code>储存</code> 页面下，进入到应用，找到 <code>仪器预约</code> 办事。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815134439.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815134746.png"></p><p>再双击打开办事，点击 <code>大型仪器</code> 表单的 <code>新增</code> 按钮，并填写仪器数据。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815134911.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815135110.png"></p><p>填写完毕后，点击 <code>预约申请</code> ，切换到 <code>预约申请</code> 子表，填写预约的开始时间和结束时间。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815135908.png"></p><p>点击提交后，办事流程会进入 <code>审批节点</code>，在管理员审批过后，数据才会存档，这一办事流程才会结束。<br>管理员切换到办事页面，会在看到一项待审批的办事<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815140119.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815140212.png"></p><p>可以在此处查看办事发起人提交的信息，审核无误后，点击通过。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815140234.png"></p><p>之后在存储页面下，双击大型仪器表单，可以查看录入的仪器数据<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814231140.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815140921.png"></p><p>预约申请事项表单只有两个字段，要想查看对应的仪器数据，应点击相应的记录查看归档痕迹，可以查看提交办事时一并提交的大型仪器子表。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230815141110.png"></p><h1 id="通过导入标准快速配置"><a href="#通过导入标准快速配置" class="headerlink" title="通过导入标准快速配置"></a>通过导入标准快速配置</h1><p>以上的教程中，从创建属性到创建表单的流程略显繁琐，在表单数量众多，属性复杂庞大的情况下会让工作量异常巨大，可以借助 <code>导入标准</code> 功能简化工作流程。</p><p>在 <code>设置</code> 页面下，左键单位右侧的三个点，或是右击目录的空白处，再依次点击 <code>新建更多&gt;导入标准</code>。<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814122702.png"></p><p>点击 <code>导入模板下载</code>：<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814123057.png"></p><p>打开下载下来的模板 xlsx 文件，该模板文件有 8 张表，可以批量导入目录、字典、分类、属性和表单信息，下面我们拿属性定义为例<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814123355.png"></p><p>例如，我们录入之前创建的属性信息：<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814124350.png"></p><blockquote><p>目录代码是新创建的属性所属的目录，目录代码可右击目录点击 <code>详细信息</code> 获得。</p></blockquote><p>之后再右击目录空白处，依次点击 <code>新建更多&gt;导入标准</code> 选择文件上传，上传之后确认录入的信息即可：<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230814201621.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本教程将引导你逐步实现一个简单的大型仪器预约应用，实现新增大型仪器以及对仪器进行预约申请。在此过程中你会学习到基于 orginone 平台进行应用开发的基本过程，同时又助于让你对 orginone 平台有更深入的理解。&lt;/p&gt;
&lt;h1 id=&quot;设置属性&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="orginone实习经历" scheme="https://coding.lilming.top/categories/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>orginone——用户手册（沟通+存储+办事）</title>
    <link href="https://coding.lilming.top/2023/07/31/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/orginone%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C%EF%BC%88%E6%B2%9F%E9%80%9A+%E5%AD%98%E5%82%A8+%E5%8A%9E%E4%BA%8B%EF%BC%89/"/>
    <id>https://coding.lilming.top/2023/07/31/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/orginone%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C%EF%BC%88%E6%B2%9F%E9%80%9A+%E5%AD%98%E5%82%A8+%E5%8A%9E%E4%BA%8B%EF%BC%89/</id>
    <published>2023-07-31T05:38:00.000Z</published>
    <updated>2023-09-14T08:19:49.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="沟通模块"><a href="#沟通模块" class="headerlink" title="沟通模块"></a>沟通模块</h1><p>点击右上角的聊天图标，进入沟通页面</p><h2 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h2><p>用户可以在侧边栏中选择群聊，或者在列表中选择群聊，另外单位也可以作为群聊，属于全员群<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731135535.png"><br>在单位和个人下存在着超级管理权群，单位下有着超级管理权的人员都会加入到该群。因为个人对自己有着最高的权限，个人页面下也会显示超级管理权群，且只有自己一人<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731140654.png"><br>点击群聊图标，进入聊天页面之后即可开始聊天<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731135745.png"></p><h2 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h2><p>同样在沟通页面下，点击个人的头像，则可显示好友以及个人，可以与好友或或者自己聊天<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731140815.png"><br>在加入的组织下，可以查看和您处于同一组织的人员，并选择与同一组织的人员聊天<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731141144.png"></p><h2 id="文件传输和存储"><a href="#文件传输和存储" class="headerlink" title="文件传输和存储"></a>文件传输和存储</h2><p>在聊天输入框的上方，点击文件图标即可选择文件上传<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731141705.png"><br>上传的文件会在聊天框中显示，可以点击文件，打开并预览文件<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731142029.png"><br>若是右击文件，还可以选择将文件下载到本地<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731142253.png"><br>所有聊天时所发送的文件都会保存在存储中，用户可以点击共享目录在存储查看<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731142513.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731142748.png"></p><h2 id="查询聊天记录"><a href="#查询聊天记录" class="headerlink" title="查询聊天记录"></a>查询聊天记录</h2><p>同样在聊天的详情下，点击查找聊天记录，在弹窗的搜索框中可以模糊搜索聊天记录<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731143039.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731143207.png"></p><h1 id="存储模块"><a href="#存储模块" class="headerlink" title="存储模块"></a>存储模块</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>点击右上角的存储图标，进入存储页面<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731143526.png"><br>可以在侧边栏中右击目录，点击上传文件，在弹窗中选择上传文件，可以选择点击或拖拽的方式上传文件<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731143500.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731143906.png"></p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>右击文件，可以对文件进行操作，如：下载，复制，剪切，彻底删除，重命名，查看详细信息，生成二维码等<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731151057.png"></p><h1 id="办事模块"><a href="#办事模块" class="headerlink" title="办事模块"></a>办事模块</h1><h2 id="发起办事"><a href="#发起办事" class="headerlink" title="发起办事"></a>发起办事</h2><p>在存储页面中点击应用，可以在引用中查看办事<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731152521.png"><br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731152546.png"><br>点击办事，填写表单信息即可<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731152648.png"></p><h2 id="审核办事"><a href="#审核办事" class="headerlink" title="审核办事"></a>审核办事</h2><p>在您发起了一则办事之后，会在“我发起的”下显示该办事，并且可以实时查看审批状态<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731153132.png"><br>若您是审批人，再他人发起了一则办事后，会在“待办事项”下显示需要审批的办事<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731153018.png"><br>点击办事之后，会打开办事的审批页面，显示办事的详细信息，可以点击通过或驳回<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731153759.png"><br>若您发起的办事审批结束，会在“已办事项”下显示已审批完毕的办事<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230731153520.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;沟通模块&quot;&gt;&lt;a href=&quot;#沟通模块&quot; class=&quot;headerlink&quot; title=&quot;沟通模块&quot;&gt;&lt;/a&gt;沟通模块&lt;/h1&gt;&lt;p&gt;点击右上角的聊天图标，进入沟通页面&lt;/p&gt;
&lt;h2 id=&quot;群聊&quot;&gt;&lt;a href=&quot;#群聊&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="orginone实习经历" scheme="https://coding.lilming.top/categories/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>orginone平台解析——anystore的api</title>
    <link href="https://coding.lilming.top/2023/07/23/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/orginone%E5%B9%B3%E5%8F%B0%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94anystore%E7%9A%84api/"/>
    <id>https://coding.lilming.top/2023/07/23/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/orginone%E5%B9%B3%E5%8F%B0%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94anystore%E7%9A%84api/</id>
    <published>2023-07-23T04:04:00.000Z</published>
    <updated>2023-09-08T03:55:38.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AnyStore-类"><a href="#AnyStore-类" class="headerlink" title="AnyStore 类"></a>AnyStore 类</h1><h2 id="getInstance"><a href="#getInstance" class="headerlink" title="getInstance"></a>getInstance</h2><p>获取任意数据存储单例。</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;getInstance&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//远端地址，默认为&quot;/orginone/anydata/hub&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="isOnline"><a href="#isOnline" class="headerlink" title="isOnline"></a>isOnline</h2><p>判断是否在线。</p><p><strong>请求方式</strong>：Post</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;isOnline&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">//无参数</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="updateToken"><a href="#updateToken" class="headerlink" title="updateToken"></a>updateToken</h2><p>更新 token。</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;updateToken&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;accessToken&quot;</span><span class="punctuation">:</span> string</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="subscribed"><a href="#subscribed" class="headerlink" title="subscribed"></a>subscribed</h2><p>订阅对象变更。</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;subscribed&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象名称</span></span><br><span class="line">        <span class="attr">&quot;callback&quot;</span><span class="punctuation">:</span> (data<span class="punctuation">:</span> any) =&gt; void<span class="comment">//变更回调函数</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="unSubscribed"><a href="#unSubscribed" class="headerlink" title="unSubscribed"></a>unSubscribed</h2><p>取消订阅对象变更。</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;unSubscribed&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象名称</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>查询对象。</p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Object&#x2F;Get&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;get&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象名称</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>修改对象。</p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Object&#x2F;Set&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;set&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象名称</span></span><br><span class="line">        <span class="attr">&quot;setData&quot;</span><span class="punctuation">:</span> any<span class="punctuation">,</span><span class="comment">//对象新的值</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>删除对象。 </p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Object&#x2F;Delete&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;delete&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象名称</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>添加数据到数据集。</p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Collection&#x2F;Update&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;insert&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;collName&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//数据集名称</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> any<span class="punctuation">,</span><span class="comment">//要添加的数据，对象/数组</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>更新数据到数据集。</p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Collection&#x2F;Update&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;update&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;collName&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//数据集名称</span></span><br><span class="line">        <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> any<span class="punctuation">,</span><span class="comment">//更新操作（match匹配，update变更,options参数）</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>从数据集移除数据。</p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Collection&#x2F;Remove&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;remove&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;collName&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//数据集名称</span></span><br><span class="line">        <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> any<span class="punctuation">,</span><span class="comment">//匹配信息</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h2><p>从数据集查询数据。</p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Collection&#x2F;Aggregate&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;aggregate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;collName&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//数据集名称</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> any<span class="punctuation">,</span><span class="comment">//聚合管道(例如：&#123;match:&#123;a:1&#125;,skip:10,limit:10&#125;)</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="pageRequest"><a href="#pageRequest" class="headerlink" title="pageRequest"></a>pageRequest</h2><p>从数据集查询数据并进行分页。</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;pageRequest&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;collName&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//数据集名称</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> any<span class="punctuation">,</span><span class="comment">//聚合管道(例如：&#123;match:&#123;a:1&#125;,skip:10,limit:10&#125;)</span></span><br><span class="line">        <span class="attr">&quot;page&quot;</span><span class="punctuation">:</span> PageModel <span class="comment">//分页模型</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="bucketOpreate"><a href="#bucketOpreate" class="headerlink" title="bucketOpreate"></a>bucketOpreate</h2><p>进行桶操作。</p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Bucket&#x2F;Operate&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;bucketOpreate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> BucketOpreateModel<span class="punctuation">,</span><span class="comment">//桶操作模型</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="fileUpdate"><a href="#fileUpdate" class="headerlink" title="fileUpdate"></a>fileUpdate</h2><p>文件上传。</p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Bucket&#x2F;Operate&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;fileUpdateOpreate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> Blob<span class="punctuation">,</span><span class="comment">//要上传的文件</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//文件的路径</span></span><br><span class="line">        <span class="attr">&quot;progress&quot;</span><span class="punctuation">:</span> ProgressEvent<span class="comment">//进度事件</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="loadThing"><a href="#loadThing" class="headerlink" title="loadThing"></a>loadThing</h2><p>加载数据。</p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Thing&#x2F;Load&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;loadThing&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> any<span class="comment">//加载选项</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="createThing"><a href="#createThing" class="headerlink" title="createThing"></a>createThing</h2><p>创建数据。</p><p><strong>请求地址</strong>：’&#x2F;orginone&#x2F;anydata&#x2F;Thing&#x2F;Create&#x2F;‘</p><p><strong>请求方式</strong>：Post</p><p><strong>参数</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;methodName&quot;</span><span class="punctuation">:</span><span class="string">&quot;createThing&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;belongId&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span><span class="comment">//对象所在域</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> string<span class="comment">//数据名称</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AnyStore-类&quot;&gt;&lt;a href=&quot;#AnyStore-类&quot; class=&quot;headerlink&quot; title=&quot;AnyStore 类&quot;&gt;&lt;/a&gt;AnyStore 类&lt;/h1&gt;&lt;h2 id=&quot;getInstance&quot;&gt;&lt;a href=&quot;#getInstanc</summary>
      
    
    
    
    <category term="orginone实习经历" scheme="https://coding.lilming.top/categories/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>orginone平台解析——沟通和储存</title>
    <link href="https://coding.lilming.top/2023/07/18/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/orginone%E5%B9%B3%E5%8F%B0%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%B2%9F%E9%80%9A%E5%92%8C%E5%82%A8%E5%AD%98/"/>
    <id>https://coding.lilming.top/2023/07/18/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/orginone%E5%B9%B3%E5%8F%B0%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%B2%9F%E9%80%9A%E5%92%8C%E5%82%A8%E5%AD%98/</id>
    <published>2023-07-18T01:49:00.000Z</published>
    <updated>2023-09-14T08:13:32.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="沟通模块"><a href="#沟通模块" class="headerlink" title="沟通模块"></a>沟通模块</h1><p>奥集能平台的聊天模块提供用户在群聊和单聊中进行自由沟通的功能。此外，也支持文件和聊天记录的储存以及查询。以下是详细的功能描述：</p><ol><li><p>群聊功能<br>用户可以在群聊中与多名用户同时进行聊天，实现集体讨论与交流。群聊功能非常适合处理工作协调、团队讨论等多人参与的情况。</p></li><li><p>单聊功能<br>若用户希望与单位下的特定成员进行一对一的沟通，可以使用单聊功能。这个功能可以帮助用户进行更为私密或者针对性的交流。</p></li><li><p>文件传输<br>在聊天过程中，用户可以发送各类文件给其他用户，该文件传输功能支持多种常见的文件格式，如文档、图片、音频、视频等，并且传输的所有文件可在共享文件中查看和下载。</p></li><li><p>聊天记录储存功能<br>所有的聊天记录都将储存在数据内核中，用户可以根据关键词查找并定位到对应的聊天记录</p></li></ol><p>从用户发送消息，再到接收方显示消息的具体时序图如下：<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230719131959.png"></p><h1 id="储存模块"><a href="#储存模块" class="headerlink" title="储存模块"></a>储存模块</h1><p>奥集能平台的储存模块秉承Linux系统中一切皆文件的概念，将平台所有的对象都抽象成了文件，包括单位、群组、用户、办事等。用户可以在储存模块下上传文件，并且支持多种常见文件格式的打开，为用户提供了一种简洁而统一的资源管理方式。以下是详细的功能描述：</p><ol><li><p>文件化抽象<br>储存模块将所有的对象都抽象为文件，这包括但不限于单位、群组、用户、办事等。这种文件化的抽象使得用户可以采用统一的方式处理和管理各种对象，大大简化了操作过程。</p></li><li><p>文件上传<br>用户可以在储存模块下上传文件，无论是文档、图片还是音频、视频等各种类型的文件。上传后的文件将以文件的形式保存在储存模块中，方便用户在需要时进行查阅和使用。</p></li><li><p>文件打开<br>储存模块支持打开多种常见的文件格式，包括但不限于 PDF、DOC、XLS、JPG、PNG、MP3、MP4等。用户上传的文件无需转换格式，直接上传后即可在平台上打开和查看。</p></li><li><p>文件管理<br>用户可以对上传的文件进行管理，包括查看文件详情、修改文件信息、删除文件等。同时，用户也可以对单位、群组、用户、办事等抽象成文件的对象进行类似的管理操作。</p></li></ol><p>从用户上传文件，查看文件的具体时序图如下：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;沟通模块&quot;&gt;&lt;a href=&quot;#沟通模块&quot; class=&quot;headerlink&quot; title=&quot;沟通模块&quot;&gt;&lt;/a&gt;沟通模块&lt;/h1&gt;&lt;p&gt;奥集能平台的聊天模块提供用户在群聊和单聊中进行自由沟通的功能。此外，也支持文件和聊天记录的储存以及查询。以下是详细的功能描述</summary>
      
    
    
    
    <category term="orginone实习经历" scheme="https://coding.lilming.top/categories/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>python爬虫----Requests库</title>
    <link href="https://coding.lilming.top/2023/07/17/Python%E7%88%AC%E8%99%AB/python%E7%88%AC%E8%99%AB----Requests%E5%BA%93/"/>
    <id>https://coding.lilming.top/2023/07/17/Python%E7%88%AC%E8%99%AB/python%E7%88%AC%E8%99%AB----Requests%E5%BA%93/</id>
    <published>2023-07-17T01:34:56.000Z</published>
    <updated>2023-07-17T01:34:58.225Z</updated>
    
    <content type="html"><![CDATA[<p><a name="6b474650"></a></p><h1 id="requests库的基本使用"><a href="#requests库的基本使用" class="headerlink" title="requests库的基本使用"></a>requests库的基本使用</h1><p><a name="c85ab9d3"></a></p><h2 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h2><p><a name="44a3f242"></a></p><h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><ul><li>r.status_code HTTP请求的返回状态，200表示连接成功，404表示失败</li><li>r.text HTTP响应内容的字符串形式，即，url对应的页面内容</li><li>r.encoding 从HTTPheader中猜测的响应内容编码方式</li><li>r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式）</li><li>r.content HTTP响应内容的二进制形式</li></ul><p><a name="e449cf10"></a></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li>requests.ConnectionError 网络连接错误异常，如DNS查询失败、拒绝连接等</li><li>requests.HTTPError HTTP错误异常</li><li>requests.URLRequired URL缺失异常</li><li>requests.TooManyRedirects 超过最大重定向次数，产生重定向异常</li><li>requests.ConnectTimeout 连接远程服务器超时异常</li><li>requests.Timeout 请求URL超时，产生超时异常</li></ul><p><a name="r.status_code"></a></p><h3 id="r-status-code"><a href="#r-status-code" class="headerlink" title="r.status_code"></a>r.status_code</h3><p>r.raise_for_status()在方法内部判断r.status_code是否等于200，不需要<br />增加额外的if语句，该语句便于利用try‐except进行异常处理</p><p><a name="162ddc62"></a></p><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requests.request()  #支持以下的所有方法，如第一个参数设置为&quot;Get&quot;</span><br><span class="line">requests.get()      #获取HTML网页的所有信息</span><br><span class="line">requests.head()     #获取HTML网页的头部信息</span><br><span class="line">requests.post()     #提交post请求，发送资源</span><br><span class="line">requests.put()      #提交put请求，会替换掉原有的资源</span><br><span class="line">requests.patch()    #提交局部修改请求</span><br><span class="line">requests.delete()   #提交删除请求</span><br></pre></td></tr></table></figure><ul><li>下面以requests.request()为例，介绍所有参数的使用</li><li>requests.request(method,url,**kwargs)</li></ul><p><a name="5f06bad4"></a></p><h3 id="method参数"><a href="#method参数" class="headerlink" title="method参数"></a>method参数</h3><p>对应请求方法有七种，和requests库的其他方法功能一致<br />除了上面的六中之外还有OPTIONS请求方法</p><p><a name="2b0eac5b"></a></p><h3 id="url参数"><a href="#url参数" class="headerlink" title="url参数"></a>url参数</h3><p>网站url地址</p><p><a name="bb92f887"></a></p><h3 id="kwargs（表示可选）"><a href="#kwargs（表示可选）" class="headerlink" title="kwargs（表示可选）"></a><strong>kwargs（</strong>表示可选）</h3><ul><li>params将键值对增加到url</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kv = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;&#125;</span><br><span class="line">r = requests.request(&#x27;GET&#x27;, &#x27;http://python123.io/ws&#x27;, params=kv)</span><br><span class="line">print(r.url)</span><br><span class="line">#http://python123.io/ws?key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure><ul><li>data将字典、字节序列或文件对象作为request的对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kv = &#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;&#125;</span><br><span class="line">r = request.request(&quot;POST&quot;,&quot;http://pythton123.io/ws&quot;,data=kv)</span><br><span class="line">body = &quot;主体内容&quot;</span><br><span class="line">r = request.request(&quot;POST&quot;,&quot;http://pythton123.io/ws&quot;,data=body)</span><br></pre></td></tr></table></figure><ul><li>json将JSON格式的数据作为requests的内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kv = &#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;&#125;</span><br><span class="line">r = request.request(&quot;POST&quot;,&quot;http://pythton123.io/ws&quot;,json=kv)</span><br></pre></td></tr></table></figure><ul><li>headers定制HTTP头部中的内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hd = &#123;&#x27;user‐agent&#x27;: &#x27;Chrome/10&#x27;&#125;</span><br><span class="line">r = requests.request(&#x27;POST&#x27;, &#x27;http://python123.io/ws&#x27;, headers=hd)</span><br></pre></td></tr></table></figure><ul><li>cookies</li><li>files字典类型，传输文件，值要用open()函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs = &#123;&#x27;file&#x27;: open(&#x27;data.xls&#x27;, &#x27;rb&#x27;)&#125;</span><br><span class="line">r = requests.request(&#x27;POST&#x27;, &#x27;http://python123.io/ws&#x27;, files=fs)</span><br></pre></td></tr></table></figure><ul><li>auth</li><li>timeout超时设置(秒为单位)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.request(&#x27;GET&#x27;, &#x27;http://www.baidu.com&#x27;, timeout=10)</span><br></pre></td></tr></table></figure><ul><li>proxies字典类型设定代理服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pxs = &#123; &#x27;http&#x27;: &#x27;http://user:pass@10.10.10.1:1234&#x27;</span><br><span class="line">&#x27;https&#x27;: &#x27;https://10.10.10.1:4321&#x27; &#125;</span><br><span class="line">r = requests.request(&#x27;GET&#x27;, &#x27;http://www.baidu.com&#x27;, proxies=pxs)</span><br></pre></td></tr></table></figure><ul><li>allow_redirects :True&#x2F;False，默认为True，重定向开关</li><li>stream:True&#x2F;False，默认为True，获取内容立即下载开关</li><li>verify:True&#x2F;False，默认为True，认证SSL证书开关</li><li>cert:本地SSL证书路径</li></ul><p><a name="d2424c30"></a></p><h2 id="爬虫的通用框架"><a href="#爬虫的通用框架" class="headerlink" title="爬虫的通用框架"></a>爬虫的通用框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">def getHtmlText(url):</span><br><span class="line">    try:</span><br><span class="line">        r = requests.get(url,timeout=30)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding()</span><br><span class="line">        return r.text</span><br><span class="line">    except:</span><br><span class="line">        return &quot;产生异常&quot;</span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">    url = &quot;http://www.baidu.com&quot;</span><br><span class="line">    print(getHtmlText(url))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;6b474650&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;requests库的基本使用&quot;&gt;&lt;a href=&quot;#requests库的基本使用&quot; class=&quot;headerlink&quot; title=&quot;requests库的基本使用&quot;&gt;&lt;/a&gt;requests库的基本使</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>python爬虫----BeautifulSoup库</title>
    <link href="https://coding.lilming.top/2023/07/17/Python%E7%88%AC%E8%99%AB/python%E7%88%AC%E8%99%AB----BeautifulSoup%E5%BA%93/"/>
    <id>https://coding.lilming.top/2023/07/17/Python%E7%88%AC%E8%99%AB/python%E7%88%AC%E8%99%AB----BeautifulSoup%E5%BA%93/</id>
    <published>2023-07-17T01:34:53.000Z</published>
    <updated>2023-07-17T01:34:54.448Z</updated>
    
    <content type="html"><![CDATA[<p><a name="c024c16d"></a></p><h1 id="导入beautifulsoup"><a href="#导入beautifulsoup" class="headerlink" title="导入beautifulsoup"></a>导入beautifulsoup</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br></pre></td></tr></table></figure><p><a name="063d6819"></a></p><h1 id="beautifulsoup方法"><a href="#beautifulsoup方法" class="headerlink" title="beautifulsoup方法"></a>beautifulsoup方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(&quot;&lt;p&gt;date&lt;/p&gt;&quot;,&quot;html.parser&quot;)</span><br><span class="line">soup = BeautifulSoup(open(&quot;D://demo.html&quot;),&quot;html.parser&quot;)</span><br></pre></td></tr></table></figure><ul><li>第一个参数是利用requests库得到的网页全代码，可以是字符串也可以是HTML文件</li><li>第二个参数是选择解析这段HTML代码的解释器</li><li>最后会得到一个能代表HTML标签树的一个实例</li><li>也可以理解为标签的集合</li></ul><p><a name="38ed9afc"></a></p><h1 id="beautifulsoup库的基本元素"><a href="#beautifulsoup库的基本元素" class="headerlink" title="beautifulsoup库的基本元素"></a>beautifulsoup库的基本元素</h1><p><a name="def47dff"></a></p><h2 id="所有的bs4库的解析器"><a href="#所有的bs4库的解析器" class="headerlink" title="所有的bs4库的解析器"></a>所有的bs4库的解析器</h2><ul><li>lxml的HTML解析器<br />条件：pip install lmxl<br />使用方法：BeautifulSoup(mk,”lmxl”)</li><li>lmxl的XML解析器<br />条件：pip install lxml<br />使用方法：BeautifulSoup(mk,”xml”)</li><li>html5lib的解析器<br />条件：pip install html5lib<br />使用条件：BeautifulSoup(mk,”html5lib”)</li></ul><p><a name="61a7d4f4"></a></p><h2 id="标签的有关元素"><a href="#标签的有关元素" class="headerlink" title="标签的有关元素"></a>标签的有关元素</h2><ul><li><p>Tag标签，最基本的信息组织元素，用&lt;&gt;和&lt;&#x2F;&gt;表明开头和结尾</p></li><li><p>Name标签的名称，如…的名称就是head</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.a.name #a</span><br><span class="line">soup.a.parent.name #div</span><br></pre></td></tr></table></figure><ul><li>Attributes标签的属性，字典类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.a.attrs </span><br><span class="line"># &#123;&#x27;class&#x27;: [&#x27;navbar-brand&#x27;], &#x27;href&#x27;: &#x27;http://www.daidaitiantian.top/&#x27;&#125;</span><br></pre></td></tr></table></figure><ul><li>NavigableString&lt;&gt;…&lt;&#x2F;&gt;中间的字符串</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.a.string</span><br><span class="line">#呆呆和甜甜</span><br></pre></td></tr></table></figure><ul><li>Comment注释类型</li></ul><p><a name="a4a23c11"></a></p><h1 id="遍历HTML的方法"><a href="#遍历HTML的方法" class="headerlink" title="遍历HTML的方法"></a>遍历HTML的方法</h1><p><a name="533ecbae"></a></p><h2 id="标签数的遍历方式"><a href="#标签数的遍历方式" class="headerlink" title="标签数的遍历方式"></a>标签数的遍历方式</h2><p><img src="http://note.youdao.com/yws/res/648/WEBRESOURCE8a9147bbf0b0ce3a208671adaf22bbbd#crop=0&crop=0&crop=1&crop=1&id=Wiso8&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><a name="dbfbb788"></a></p><h2 id="下行遍历"><a href="#下行遍历" class="headerlink" title="下行遍历"></a>下行遍历</h2><ul><li>contents子节点的列表，将所有子节点存入列表</li><li>children子节点的迭代类型，与contents类似用于遍历子节点</li><li>descendants子孙节点的迭代类型，用于循环遍历</li></ul><p><a name="ede05cbe"></a></p><h2 id="上行遍历"><a href="#上行遍历" class="headerlink" title="上行遍历"></a>上行遍历</h2><ul><li>parent节点的父标签</li><li>parents节点先辈标签的迭代类型，用于遍历</li></ul><p><a name="b57148a0"></a></p><h2 id="平行遍历"><a href="#平行遍历" class="headerlink" title="平行遍历"></a>平行遍历</h2><ul><li>next_sibling下一个平行节点的标签</li><li>previous_sibling上一平行节点的标签</li><li>next_sblings后续所有平行节点的迭代类型</li><li>previous_sblinga前面所有平行节点的迭代类型<br />不是同一父节点下的标签不是平行关系<br />有可能返回的是NavigableString属性，后面会介绍排除的方法</li></ul><p><a name="ff1aba7d"></a></p><h1 id="HTML格式输出和编码"><a href="#HTML格式输出和编码" class="headerlink" title="HTML格式输出和编码"></a>HTML格式输出和编码</h1><ul><li>prettify()能够格式化输出Html内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup = beautifulsoup(&quot;&lt;p&gt;呆呆和甜甜&lt;/p&gt;&quot;，&quot;html.parser&quot;)</span><br><span class="line">print(soup.p.prettify)</span><br><span class="line"># &lt;p&gt;</span><br><span class="line">#   呆呆和甜甜</span><br><span class="line"># &lt;/p&gt;</span><br></pre></td></tr></table></figure><p><a name="f359139e"></a></p><h1 id="lt-gt-find-all"><a href="#lt-gt-find-all" class="headerlink" title="&lt;&gt;.find_all()"></a>&lt;&gt;.find_all()</h1><ul><li>返回的是一个列表</li></ul><p><a name="3d0a2df9"></a></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><a name="9ee23a89"></a></p><h3 id="name需要检索的标签名字符串"><a href="#name需要检索的标签名字符串" class="headerlink" title="name需要检索的标签名字符串"></a>name需要检索的标签名字符串</h3><ul><li>如果是True则打印所有标签</li><li>要打印多个标签可使用列表</li></ul><p><a name="19e3b452"></a></p><h3 id="attrs标签属性检索字符串"><a href="#attrs标签属性检索字符串" class="headerlink" title="attrs标签属性检索字符串"></a>attrs标签属性检索字符串</h3><ul><li>也可以对一个特定的属性值进行检索<br />要加下划线，如：class_</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(id_ = &quot;link&quot;)</span><br><span class="line"># 搜索出属性包含id= link的标签</span><br></pre></td></tr></table></figure><p><a name="ad73f43f"></a></p><h3 id="recursive-是否对子孙全部检索，默认是True"><a href="#recursive-是否对子孙全部检索，默认是True" class="headerlink" title="recursive 是否对子孙全部检索，默认是True"></a>recursive 是否对子孙全部检索，默认是True</h3><p><a name="e3c2dd0a"></a></p><h3 id="srting对-lt-gt-…-lt-x2F-gt-中间的内容进行检索"><a href="#srting对-lt-gt-…-lt-x2F-gt-中间的内容进行检索" class="headerlink" title="srting对&lt;&gt;…&lt;&#x2F;&gt;中间的内容进行检索"></a>srting对&lt;&gt;…&lt;&#x2F;&gt;中间的内容进行检索</h3><p><a name="d8771b35"></a></p><h2 id="find——all的简写形式"><a href="#find——all的简写形式" class="headerlink" title="find——all的简写形式"></a>find——all的简写形式</h2><ul><li>() &#x3D;&#x3D;.find_all()</li><li>soup() &#x3D;&#x3D; soup.find_all()</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;c024c16d&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;导入beautifulsoup&quot;&gt;&lt;a href=&quot;#导入beautifulsoup&quot; class=&quot;headerlink&quot; title=&quot;导入beautifulsoup&quot;&gt;&lt;/a&gt;导入beautifu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA基础速查速记</title>
    <link href="https://coding.lilming.top/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/JAVA%E5%9F%BA%E7%A1%80%E9%80%9F%E6%9F%A5%E9%80%9F%E8%AE%B0/"/>
    <id>https://coding.lilming.top/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/JAVA%E5%9F%BA%E7%A1%80%E9%80%9F%E6%9F%A5%E9%80%9F%E8%AE%B0/</id>
    <published>2023-07-13T01:56:00.000Z</published>
    <updated>2023-09-08T03:58:50.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="内置类型和包装类"><a href="#内置类型和包装类" class="headerlink" title="内置类型和包装类"></a>内置类型和包装类</h2><table><thead><tr><th>包装类</th><th>基本数据类型</th></tr></thead><tbody><tr><td>Boolean</td><td>boolean</td></tr><tr><td>Byte</td><td>byte</td></tr><tr><td>Short</td><td>short</td></tr><tr><td>Integer</td><td>int</td></tr><tr><td>Long</td><td>long</td></tr><tr><td>Character</td><td>char</td></tr><tr><td>Float</td><td>float</td></tr><tr><td>Double</td><td>double</td></tr></tbody></table><h3 id="Number-与-Math"><a href="#Number-与-Math" class="headerlink" title="Number 与 Math"></a>Number 与 Math</h3><blockquote><p>java 将一个内置类型直接赋值给一个包装类是可以的，叫做自动装箱，反之叫拆箱。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> c;</span><br><span class="line">System.out.println(ch);  <span class="comment">// 输出：a</span></span><br><span class="line"></span><br><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ch;</span><br><span class="line">System.out.println(c);  <span class="comment">// 输出：a</span></span><br></pre></td></tr></table></figure><p>Number 常用的方法：</p><ul><li>XXX.valueOf: 返回一个 Number 对象指定的数据类型</li><li>equals()：判断是非相等（类型和值都要相同才返回true）</li><li>compareTo()：与 number 对象相比较</li><li>toString()：转换成字符串</li><li>Integer.parseInt()：将字符串转换成 int（建议使用valueOf）<ul><li>Double.parseDouble</li><li>Long.parseLong</li></ul></li></ul><p>Math 的常用方法：</p><ul><li>abs()：返回参数的绝对值</li><li>ceil()：向上取整</li><li>floor()：向下取整</li><li>round()：四舍五入（Math.floor(x+0.5)）</li><li>min()：返回参数的最小值</li><li>max()：返回参数的最大值</li><li>exp()：返回 e 的参数次方</li><li>log()：返回 log 以 e 为底的参数</li><li>pow(x,y)：返回 x 的 y 次方</li><li>sqrt()：返回参数的开方</li><li>random()：返回一个 0 到 1 的随机数</li></ul><h3 id="Character-类"><a href="#Character-类" class="headerlink" title="Character 类"></a>Character 类</h3><blockquote><p>Character 是 char 的包装类</p></blockquote><p>定义一个 char[]：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] charArray =&#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><p>定义一个 Character：直接将 char 赋值给Character</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>char[]不能直接赋值给 Character[]，要遍历 char[]一个一个赋值</p><p>Character、类的方法</p><ul><li>isLetter()：判断是否是一个字母</li><li>isDigit()：判断是否是一个数字</li><li>isWhitespace()：判断是否是一个空白字符</li><li>isUpperCase()：</li><li>isLowerCase()：</li><li>toUpperCase()：</li><li>toLowerCase()：</li><li>toStrig()：</li></ul><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><p>格式化字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fs</span> <span class="operator">=</span> String.format(<span class="string">&quot;浮点型变量的值为 &quot;</span> + <span class="string">&quot;%f, 整型变量的值为 &quot;</span> + <span class="string">&quot; %d, 字符串变量的值为 &quot;</span> + <span class="string">&quot; %s&quot;</span>, floatVar, intVar, stringVar);</span><br></pre></td></tr></table></figure><p>其他方法：</p><ul><li>char charAt(int)：返回指定索引下的 char</li><li>String copyValueOf(char[])：返回 char[]的字符串形式</li><li>String copyValueOf(char[], index, count):从 char[]的 index 下标开始，复制 count 个字符</li><li>boolean endsWith(string)：字符串是否以指定的后缀结束</li><li>boolean equals(string)：判断字符串是否相等</li><li>boolean equalsIgnoreCase(string)：判断字符串是否相等，不考虑大小写</li><li>int indexOf(string,int): 从下标 int 的位置开始返回指定 string 的索引值，找不到返回-1</li><li>String trim()：返回给定字符串去除前后空值的副本</li><li>char[] toCharArray()：将字符串转换成 char[]</li><li>boolean contains(char|string)：判断字符串是否包含指定字符或字符串</li><li>String valueOf(x)：返回 x 的字符串形式</li><li>String toLowerCase()：将字符串的字母都转换成小写</li><li>String subString(int Begin, int end)：截取指定索引范围的字符串</li></ul><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>建立 <code>StringBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立一个容量为10的StringBuilder</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>StringBuilder 方法：</p><ul><li>append(String)：追加指定字符串</li><li>reverse()：反转字符串</li><li>delete(int start, int end)：删除指定索引的元素</li><li>insert(int index, String str)：将 str 插入到指定的位置</li><li>replace(int start, int end， String str)：将str替换指定索引的字符串</li><li>String toString()：将 StringBuilder 转换成字符串</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的方法：</p><ul><li>int binarySearch(Object[] a, Object key)：在 a 数组中按二分查找查找 key，给定的数组是已排序好的</li><li>void fill(Object[] a, Object key)：用 key 填充 a 数组</li><li>void sort(Objext[])：升序排序数组</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul><li>add(int index，E e)：在指定 index 索引处添加元素</li><li>get(int index)：返回 index 索引处的元素</li><li>set(int index, E e)：修改指定 index 索引处的元素</li><li>remove(int index)：移除 index 索引处的元素</li><li>bolean remove(Object o)：删除某一元素，成功返回true</li><li>size()：返回链表元素的个数</li><li>addAll(int index, List | Set)：将 List 内的所有元素插入到 index 的索引位置（默认最后）</li></ul><h3 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h3><p>除了 <code>ArrayList</code> 有的方法之外还有：</p><ul><li>addFirst()：</li><li>addLast()：</li><li>removeFirst()：</li><li>removeLast()：</li><li>getFirst()：</li><li>getLast()：</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p><p>创建 Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; Sites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br></pre></td></tr></table></figure><p>方法如下：</p><ul><li>put(key, value)：添加元素</li><li>get(key)：获取元素</li><li>remove(key)：移除元素</li><li>size()：键值对个数</li></ul><p>在对 Map 对象进行排序时，可以将 key 值作为关键词。利用 <code>TreeMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; sortedMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(unsortedMap);</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections 类是 Java 提供的一个操作 Set、List 和 Map 等集合的工具类<br>方法如下：</p><ul><li>void reverse(List)：逆序List</li><li>void sort(List)：升序 List</li><li>void sort(List, Comparator)：根据指定的 Comparator 产生的序列对 List 排序</li><li>void swap(List, int i, int j)：指定 List 的 i 和 j 进行互换</li><li>void rotate(List, int distance)：当 distance 为正数时将 List 集合的后 distance 个元素整体移动到头部；当 distance 为负数时将 List 集合的前 distance 个元素整体移动到末尾</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h1&gt;&lt;h2 id=&quot;内置类型和包装类&quot;&gt;&lt;a href=&quot;#内置类型和包装类&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="计算机语言知识库" scheme="https://coding.lilming.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>清除浮动的三种常用方式</title>
    <link href="https://coding.lilming.top/2023/07/10/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://coding.lilming.top/2023/07/10/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2023-07-10T07:12:00.000Z</published>
    <updated>2023-09-08T13:04:27.175Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了三种清除浮动的方法，并尝试解释其原理。在理解了各种清除浮动的原理之后，你会发现，很多清除浮动的方法本质上其实是一样的。掌握这些原理，相信你可以根据场景和需求，灵活运用原则发展出不同的清除浮动的方法，而不再死记或拘泥于文中提到的方法。</p><h2 id="一、为什么要清除浮动"><a href="#一、为什么要清除浮动" class="headerlink" title="一、为什么要清除浮动"></a>一、为什么要清除浮动</h2><p>在讲清除浮动的方法之前，我们先来了解一下为什么要清除浮动，清除浮动的目的是什么，即，要解决什么样的问题。来看一个浮动的例子(略去了文字内容)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;topDiv&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;floatDiv&quot;</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;textDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottomDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其样式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.topDiv</span> &#123;     </span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;     </span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid black; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.floatDiv</span> &#123;     </span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;     </span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;     </span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> dotted red;    </span><br><span class="line"><span class="attribute">color</span>: red;     </span><br><span class="line"><span class="attribute">margin</span>: <span class="number">4px</span>;     </span><br><span class="line"><span class="attribute">float</span>: left; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bottomDiv</span> </span><br><span class="line">&#123;     </span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;     </span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;     </span><br><span class="line"><span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;     </span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> dotted black; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.textDiv</span> </span><br><span class="line">&#123;     </span><br><span class="line"><span class="attribute">color</span>: blue;     </span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid blue; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在chrome中渲染的效果如下图所示：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/18/2af797ffc0918352ac8d381994ff1a27~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="浮动效果"></p><p>这肯定不是我们想要的渲染效果，它可能存在如下问题：</p><ol><li>文字围绕浮动元素排版，但我们可能希望文字（<code>.textDiv</code>）排列在浮动元素下方，或者，我们并不希望<code>.textDiv</code>两边有浮动元素存在。</li><li>浮动元素排版超出了其父级元素（<code>.topDiv</code>），父元素的高度出现了塌缩，若没有文字高度的支撑，不考虑边框，父级元素高度会塌缩成零。</li><li>浮动元素甚至影响到了其父元素的兄弟元素（<code>.bottomDiv</code>）排版。因为浮动元素脱离了文档流，<code>.bottomDiv</code>在计算元素位置的时候会忽略其影响，紧接着上一个元素的位置继续排列。</li></ol><p>解决第一个问题，需要清除<code>.textDiv</code>周围的浮动，而解决第二个问题，因为父元素的兄弟元素位置只受父元素位置的影响，就需要一种方法将父级元素的高度撑起来，将浮动元素包裹在其中，避免浮动元素影响父元素外部的元素排列。</p><p>接下来开始介绍清除浮动的方法。</p><h2 id="二、清除浮动的方法"><a href="#二、清除浮动的方法" class="headerlink" title="二、清除浮动的方法"></a>二、清除浮动的方法</h2><h3 id="1-父元素结束标签之前插入清除浮动的块级元素"><a href="#1-父元素结束标签之前插入清除浮动的块级元素" class="headerlink" title="1. 父元素结束标签之前插入清除浮动的块级元素"></a>1. 父元素结束标签之前插入清除浮动的块级元素</h3><p>HTML结构如下，在有浮动的父级元素的末尾插入了一个没有内容的块级元素div：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;topDiv&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;textDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;floatDiv&quot;</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;blankDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottomDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.topDiv</span> &#123;     </span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;     </span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.floatDiv</span> &#123;     </span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;     </span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> dotted red;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">4px</span>;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.bottomDiv</span> &#123;     </span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;     </span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> dotted black;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.textDiv</span> &#123;     </span><br><span class="line"><span class="attribute">color</span>: blue;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//区别在这里</span></span><br><span class="line"><span class="selector-class">.blankDiv</span> &#123;    </span><br><span class="line"><span class="attribute">clear</span>: both; <span class="comment">// or left</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/18/7e3621e15592ac42f86c70734fe4e1dc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image"></p><p>通过上面的样式，<code>.blankDiv</code> 告诉浏览器，我的左边不允许有浮动的元素存在，请清除掉我左边的浮动元素。然而，因为浮动元素（<code>.floatDiv</code>）位置已经确定，浏览器在计算 <code>.blankDiv</code> 的位置时，为满足其需求，将 <code>.blankDiv</code> 渲染在浮动元素下方，保证了 <code>.blankDiv</code> 左边没有浮动元素。同时可以看出，父元素的高度也被撑起来了，其兄弟元素的渲染也不再受到浮动的影响，这是因为 <code>.blankDiv</code> 仍然在文档流中，它必须在父元素的边界内，父元素只有增加其高度才能达到此目的，可以说是一个意外收获。(<code>clear</code> 的值为 <code>both</code> 也有相同的效果，通俗理解就是，哪边不允许有浮动元素，clear 就是对应方向的值，两边都不允许就是 <code>both</code>)</p><h3 id="2-利用伪元素（clearfix）"><a href="#2-利用伪元素（clearfix）" class="headerlink" title="2. 利用伪元素（clearfix）"></a>2. 利用伪元素（clearfix）</h3><p>HTML 结构如下，为了惯例相符，在 <code>.topDiv</code> 的 div 上再添加一个<code>clearfix</code>类：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;topDiv clearfix&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;textDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;floatDiv&quot;</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottomDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>样式应用如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略基本的样式 </span></span><br><span class="line"><span class="comment">// 区别在这里 </span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;     </span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;.&#x27;</span>;   </span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该样式在<code>clearfix</code>，即父级元素的最后，添加了一个<code>:after</code>伪元素，通过清除伪元素的浮动，达到撑起父元素高度的目的。注意到该伪元素的<code>display</code>值为<code>block</code>，即，它是一个不可见的块级元素（有的地方使用<code>table</code>，因为<code>table</code>也是一个块级元素）。你可能已经意识到，这也只不过是前一种清除浮动方法（添加空白div）的另一种变形，其底层逻辑也是完全一样的。前面的三种方法，其本质上是一样的。</p><h3 id="3-利用-overflow-清除浮动"><a href="#3-利用-overflow-清除浮动" class="headerlink" title="3. 利用 overflow 清除浮动"></a>3. 利用 overflow 清除浮动</h3><p>首先直观地看看，<code>overflow</code>是如何清除浮动的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;topDiv&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;floatDiv&quot;</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;textDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottomDiv&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.topDiv</span> &#123;    </span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;   </span><br><span class="line"><span class="attribute">padding</span>: <span class="number">4px</span>;   </span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid black;  </span><br><span class="line"><span class="comment">// 区别在这里  </span></span><br><span class="line"><span class="attribute">overflow</span>: auto; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.floatDiv</span>&#123;   </span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;   </span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> dotted red;  </span><br><span class="line"><span class="attribute">color</span>: red;   </span><br><span class="line"><span class="attribute">margin</span>: <span class="number">4px</span>;   </span><br><span class="line"><span class="attribute">float</span>: left; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.bottomDiv</span> &#123;    </span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;   </span><br><span class="line"><span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;    </span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> dotted black; </span><br><span class="line"><span class="attribute">clear</span>: both; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.textDiv</span> &#123; </span><br><span class="line"><span class="attribute">color</span>: blue;   </span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid blue; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不应用上面标识出来的CSS时，渲染结果和本文开始的第一个图形效果相同，应用CSS后的渲染效果如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/18/cb75fb0469d3316e2ca6192f8316f7cb~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image"></p><p>仅仅只在父级元素上添加了一个值为auto的overflow属性，父元素的高度立即被撑起，将浮动元素包裹在内。看起来，浮动被清除了，浮动不再会影响到后续元素的渲染（严格讲，这和清除浮动没有一点关系，因为不存在哪个元素的浮动被清除，不纠结这个问题）。其实，这里的overflow值，还可以是除了”visible”之外的任何有效值，它们都能达到撑起父元素高度，清除浮动的目的。不过，有的值可能会带来副作用，比如，scroll值会导致滚动条始终可见，hidden会使得超出边框部分不可见等。那它们是如何做到浮动清除的呢？</p><p>要讲清楚这个解决方案的原理，有一个概念始终是绕不过去，那就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">块格式化上下文(BFC)</a>,然而这又是一个非常抽象的概念，如果要清楚地把这个概念讲出来，恐怕需要非常大的篇幅，这里仅提及和理解该问题相关的内容。</p><p>这是从<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context">MDN</a>上摘下来的BFC定义：</p><blockquote><p>A block formatting context is a part of a visual CSS rendering of a Web page. It is the region in which the layout of block boxes occurs and in which floats interact with each other.</p></blockquote><p>翻译过来就是：块级格式化上下文是CSS可视化渲染的一部分。它是一块区域，规定了内部块盒的渲染方式，以及浮动相互之间的影响关系。</p><p>块格式化上下文（BFC）有下面几个特点：</p><ol><li>BFC是就像一道屏障，隔离出了BFC内部和外部，内部和外部区域的渲染相互之间不影响。BFC有自己的一套内部子元素渲染的规则，不影响外部渲染，也不受外部渲染影响。</li><li>BFC的区域不会和外部浮动盒子的外边距区域发生叠加。也就是说，外部任何浮动元素区域和BFC区域是泾渭分明的，不可能重叠。</li><li>BFC在计算高度的时候，内部浮动元素的高度也要计算在内。也就是说，即使BFC区域内只有一个浮动元素，BFC的高度也不会发生塌缩，高度是大于等于浮动元素的高度的。</li><li>HTML结构中，当构建BFC区域的元素紧接着一个浮动盒子时，即，是该浮动盒子的兄弟节点，BFC区域会首先尝试在浮动盒子的旁边渲染，但若宽度不够，就在浮动元素的下方渲染。<a href="https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float">看这里</a></li></ol><p>有了这几点，就可以尝试解释为什么<code>overflow</code>（值不为<code>visible</code>）可以清除浮动了。</p><p>当元素设置了<code>overflow</code>样式，且值不为<code>visible</code>时，该元素就建构了一个BFC(哪些情况下，元素可以建构出BFC，可以看查看CSS文档对<a href="https://www.w3.org/TR/CSS2/visuren.html#block-formatting">BFC的定义</a>)。在我们的例子中，<code>.topDiv</code>因设置了值为<code>auto</code>的<code>overflow</code>样式，所以该元素建构出一个BFC，按照第三个特点，BFC的高度是要包括浮动元素的，所以<code>.topDiv</code>的高度被撑起来，达到了清除浮动影响的目的。(至于为什么值为<code>visible</code>的<code>overflow</code>不能建构BFC，<a href="https://stackoverflow.com/questions/9943503/why-does-css2-1-define-overflow-values-other-than-visible-to-establish-a-new-b?answertab=votes#tab-top">这个答案</a>给了一个解释)</p><p>其实，这里overflow的作用就是为了构建一个BFC区域，让内部浮动的影响都得以“内化”。如果你看了<a href="https://www.w3.org/TR/CSS2/visuren.html#block-formatting">BFC的定义</a>，你会发现，构建一个BFC区域的方法有很多种，<code>overflow</code>只是其中的一种，那在这里，我们是否也可以利用其它的方式构建BFC，且同样能达到清除浮动的目的呢？</p><p>BFC定义中说，<code>inline-block</code>同样也能构建BFC，那我们就用该样式来试试：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.topDiv</span> &#123;     </span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;     </span><br><span class="line"><span class="attribute">padding</span>: <span class="number">4px</span>;    </span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid black;    </span><br><span class="line"><span class="comment">// 区别在这里    </span></span><br><span class="line"><span class="attribute">display</span>: inline-block; &#125; </span><br><span class="line"><span class="comment">// 其他样式相同，省略</span></span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/18/aa859ff15404ede93450f03430b2d3ba~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image"></p><p>效果完全一样！只要我们理解了原理，就可以灵活演变出不同的清除浮动的方法，而不必死记某种手段。</p><p>当然，要说明的是，在实际项目中选择采用哪种方式构建BFC是要具体问题具体分析的，因为要考虑到选用的样式自身的作用和影响。这个例子中，选用<code>inline-block</code>和选用<code>overflow</code>效果完全一样，没有看出有什么副作用，但不代表在其他项目中一样能行得通。甚至对<code>overflow</code>值的选择也要考虑其表现和影响。在各种构建BFC的方式中，<code>overflow</code>方式可能是外部影响更可控的一种，我猜想这也许就是为什么普遍采用<code>overflow</code>来清除浮动的原因吧。</p><p>到这里，我要分享的清除浮动的方法已经讲完了。其实，如果在不同的使用场景下，对这几个方法进行拆分组合(其实是对底层原理的拆分组合)，还可以实现其他形式不同的清除浮动的方法，最重要的还是对底层原理的把握。知其然，亦知其所以然才是最有效的学习方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文介绍了三种清除浮动的方法，并尝试解释其原理。在理解了各种清除浮动的原理之后，你会发现，很多清除浮动的方法本质上其实是一样的。掌握这些原理，相信你可以根据场景和需求，灵活运用原则发展出不同的清除浮动的方法，而不再死记或拘泥于文中提到的方法。&lt;/p&gt;
&lt;h2 id=&quot;一、为</summary>
      
    
    
    
    <category term="前端学习" scheme="https://coding.lilming.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前端" scheme="https://coding.lilming.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="常用技巧" scheme="https://coding.lilming.top/tags/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>orginone平台解析——SignalR通信</title>
    <link href="https://coding.lilming.top/2023/07/04/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/orginone%E5%B9%B3%E5%8F%B0%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94SignalR%E9%80%9A%E4%BF%A1/"/>
    <id>https://coding.lilming.top/2023/07/04/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/orginone%E5%B9%B3%E5%8F%B0%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94SignalR%E9%80%9A%E4%BF%A1/</id>
    <published>2023-07-04T08:21:00.000Z</published>
    <updated>2023-09-08T03:55:33.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Storehub"><a href="#Storehub" class="headerlink" title="Storehub"></a>Storehub</h1><blockquote><p>关于 SignalR.HubConnection 的官方文档（不过官方貌似没有中文版的）： <a href="https://learn.microsoft.com/zh-cn/javascript/api/@microsoft/signalr/hubconnection?view=signalr-js-latest">https://learn.microsoft.com/zh-cn/javascript/api/@microsoft/signalr/hubconnection?view=signalr-js-latest</a><br>对 SignIR 还不是很熟悉，和传统的 axios 请求不太一样，之后再继续学习这一块</p></blockquote><p>Storehub 功能是用来和服务器建立 SignIR 连接的</p><ol><li>constructor 构造方法：构造函数，用于建立与 SignalR 服务器的连接。主要是初始化了私有对象_connection，这是用来和 SignalR 服务器的连接的对象，后面的 invoke 就是通过这一方式和服务器连接的</li><li>isConnected：检查是否连接</li><li>dispose：销毁连接</li><li>_starting：初次开始连接</li><li>start：启动连接，如果没有启动，则调用_starting</li><li>restart：重新建立连接，先停止连接，之后调用start</li><li>onConnected：连接成功的回调函数，传入一个返回 <code>void</code> 的函数，用来在_starting 中执行</li><li>onDisconnected：断开连接的回调，和成功连接的回调类似，在销毁连接时执行</li><li>on：<ol><li>接收两个参数一个是字符串（方法名），第二个是函数</li><li>这也是一个回调函数，官网上的解释是说注册一个处理程序，当调用具有指定方法名称的集线器方法时将调用该处理程序。我的理解是客户端去监听服务器，当服务器执行了第一个参数指定的方法时，就去执行后面的函数</li><li>例如：<br>当服务器执行了 updated 方法后，会将结果传入第二个参数所定义的函数，从而做到服务器去调用客户端的方法<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_storeHub</span>.<span class="title function_">on</span>(<span class="string">&#x27;updated&#x27;</span>, <span class="function">(<span class="params">belongId, key, data</span>) =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_updated</span>(belongId, key, data);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li>invoke：这是用来调用服务器的方法<ol><li>接收的参数分为两个部分，第一个是调用的服务器端的方法，第二个是传入的参数</li><li>例如：在 kernelapi 中的登录方法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = await this._storeHub.invoke(&#x27;Login&#x27;, req);</span><br></pre></td></tr></table></figure>我在 invoke 中打印了请求的方法和对应的请求结果：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_connection</span>  </span><br><span class="line">  .<span class="title function_">invoke</span>(methodName, ...args)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res: ResultType&lt;<span class="built_in">any</span>&gt;</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">//打印请求结果 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(methodName);  <span class="comment">//打印请求方法</span></span><br><span class="line"><span class="comment">//其他的代码省略</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><img src="/static/62adada267390657a16b2233edd71c7.png"></li></ol></li></ol><h1 id="anyStore"><a href="#anyStore" class="headerlink" title="anyStore"></a>anyStore</h1><p>anyStore 功能主要是用来管理服务器的数据的，比如存储的文件，使用的连接方法是调用上面的 Storehub 对象</p><ol><li>_restRequest:使用 axios 请求后端，在 anyStore 的每一个方法下都会先判断一次，如果 StoreHub 没有连接上才会用 axios 请求，以下是 anyStore 涉及到的方法</li><li>对物的操作：创建、加载。物是平台中抽象的一个概念，把平台中所有的对象都抽象成物</li><li>对文件的操作：上传、查看</li><li>对 token 的操作：更新 token 到缓存中、获取 token</li><li>对对象的操作：查询、修改、删除</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Storehub&quot;&gt;&lt;a href=&quot;#Storehub&quot; class=&quot;headerlink&quot; title=&quot;Storehub&quot;&gt;&lt;/a&gt;Storehub&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;关于 SignalR.HubConnection 的官方文档（不过</summary>
      
    
    
    
    <category term="orginone实习经历" scheme="https://coding.lilming.top/categories/orginone%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>React路由踩坑</title>
    <link href="https://coding.lilming.top/2023/07/01/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/React%E8%B7%AF%E7%94%B1%E8%B8%A9%E5%9D%91/"/>
    <id>https://coding.lilming.top/2023/07/01/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/React%E8%B7%AF%E7%94%B1%E8%B8%A9%E5%9D%91/</id>
    <published>2023-07-01T14:43:00.000Z</published>
    <updated>2023-09-14T08:09:07.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误实例"><a href="#错误实例" class="headerlink" title="错误实例"></a>错误实例</h1><p>在一些版本较老的 React 的项目里你可能会看到这样的路由跳转方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Redirect</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 设置默认进入登录页面  </span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RedirectPage</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/passport/login&quot;</span> /&gt;</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而你把这段代码放入最新的 React 项目中会有报错<br><img src="https://lilming-obsidian.oss-cn-hangzhou.aliyuncs.com/pic/Pasted%20image%2020230701224929.png"><br>报错显示不存在 Redirect，这是因为在 v6 版本的 react-router-dom 中移除了 Redirect</p><h1 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h1><p>在 <code>react-router-dom</code> 的 v6 版本中，<code>Redirect</code> 组件已经被移除了，取而代之的是 <code>useNavigate</code> Hook 和 <code>navigate</code> 函数</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;useEffect&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> &#123; useNavigate &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 设置默认进入登录页面  </span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RedirectPage</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>();  </span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;  </span><br><span class="line">        <span class="title function_">navigate</span>(<span class="string">&#x27;/passport/login&#x27;</span>)  </span><br><span class="line">    &#125;,[])  </span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">RedirectPage</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;错误实例&quot;&gt;&lt;a href=&quot;#错误实例&quot; class=&quot;headerlink&quot; title=&quot;错误实例&quot;&gt;&lt;/a&gt;错误实例&lt;/h1&gt;&lt;p&gt;在一些版本较老的 React 的项目里你可能会看到这样的路由跳转方法&lt;/p&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    <category term="踩坑记录" scheme="https://coding.lilming.top/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>React基础知识入门</title>
    <link href="https://coding.lilming.top/2023/06/20/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8/"/>
    <id>https://coding.lilming.top/2023/06/20/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8/</id>
    <published>2023-06-20T05:19:00.000Z</published>
    <updated>2023-09-08T03:58:35.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="categories"><a href="#categories" class="headerlink" title="categories:"></a>categories:</h2><h2 id="这篇-React-基础入门是结合-React-和-TS-来使用的，会比一般的-JS-加-React-的项目复杂的多，不过就我目前接触到的项目，采用-TS-居多，JS-越来越少了，大厂或许-TS-用的更多吧（我猜的）。我参照的学习资料来自掘金的一篇文章以及官方的入门教程，我的个人习惯一向是参照文字教程-动手写-demo-＋做项目，视频是真的看不下去，如果是国外的教程有优质的翻译还好，国内的教程质量不能说是很差吧，只是我不习惯这种按照老师讲课的方式，更倾向于文字形式能挑重点看，跳过已经掌握的部分再说说实战视频吧，实战部分的案例都被用得太烂了，如果仅仅只是为了提升技术那么完全没有做的必要，直接参与竞赛或者老师的课题，以解决问题为导向，对自己技术的提升真的很大，实在没有也可以看看-github-的优质项目。-创建-React-项目-确保安装了-node-js-后就可以使用命令安装-react-gt-my-app-为创建的-react-项目名-初始-jsx-与组件-gt-下面介绍有关-React-的基础知识-创建-React-组件-React-通常有一个主入口文件，如：index-js-或-index-tsx-首先利用-ReactDOM-createRoot-创建一个-root-document-getElementById-作用是什么？-gt-获取一个-id-为“root”的-HTML-元素作为-React-的挂载点，将其组件挂载到这个容器上-Id-为什么是“root”-gt-在-public-目录下，和-index-html-文件里命名的元素有关，可以自定义命名-之后再用-root-render-将内部的-React-组件（）渲染到-root（根容器）中-App-组件是你引入的一个-React-组件-先在-App-jsx-文件里创建-JS-函数，函数里返回标签，这就是一个-React-组件了-gt-注意：-gt-React-组件必须以大写字母开头-gt-最外层的标签必须闭合，这和-HTML-不同-要想组件在其他的组件里去使用要用-export-defsult-添加样式-使用-className-指定一个样式表-条件渲染-if-语句-三元表达式-短路运算（逻辑中断）-列表渲染-利用-Array-的-map-方法来渲染列表-gt-循环的标签一定要有-key-属性，分配一个唯一的值，不然会有警告-响应事件-在函数组件内部声明一个事件处理函数来响应事件-组件-函数组件-函数名大写开头，函数内返回标签-渲染函数组件-gt-直接使用标签-箭头函数语法-类组件1-必须继承-React-Component-父类2-必须有一个-render-方法3-render-方法必须要有返回值-类组件的渲染和函数组件一致-绑定事件-函数组件绑定事件-类组件绑定事件-gt-在类中定义事件函数，要用-this-funName-的方式引用-事件对象-通过-preventDefault-方法获取到事件对象，阻止运行-插值和状态-class-写法和-Hook-写法-gt-在前面说到-react-的组件由两种写法，一个是-class，一个是-function，在-react18-出来之前，函数组件是不能改变组件内部的值的，要做到动态的效果只能用-class，在-react18-出来之后，添加了一个新特性：Hook。可以在函数组件里定义变量，并修改变量了，在一些老的教程里没有提到这一点，我在这一点上吃了一点亏，既然官方推出了这个特新肯定是希望能成为主流去用的，比如在-react-官网教程里用的就是这个方式，所以在学习这一部分时，尽量还是以-Hook-为主，class-过一遍就好了-class-写法-初始化数据：state-x3D-，state-是组件内部的私有数据，只能在组件内部使用，相当于-java-对象的私有变量。state-的值是一个对象，表示组件内部的多个数据-修改数据：this-setState-要修改的值-，注意：不能直接修改state-gt-注意，在事件函数里存在-this-指向的问题，非箭头函数函数不能直接使用-this-setState-，因为这个-this-不是-class-的-this。-gt-箭头函数没有他自己的-this，他的-this-是由外面一层的-this-决定的-Hook-写法"><a href="#这篇-React-基础入门是结合-React-和-TS-来使用的，会比一般的-JS-加-React-的项目复杂的多，不过就我目前接触到的项目，采用-TS-居多，JS-越来越少了，大厂或许-TS-用的更多吧（我猜的）。我参照的学习资料来自掘金的一篇文章以及官方的入门教程，我的个人习惯一向是参照文字教程-动手写-demo-＋做项目，视频是真的看不下去，如果是国外的教程有优质的翻译还好，国内的教程质量不能说是很差吧，只是我不习惯这种按照老师讲课的方式，更倾向于文字形式能挑重点看，跳过已经掌握的部分再说说实战视频吧，实战部分的案例都被用得太烂了，如果仅仅只是为了提升技术那么完全没有做的必要，直接参与竞赛或者老师的课题，以解决问题为导向，对自己技术的提升真的很大，实在没有也可以看看-github-的优质项目。-创建-React-项目-确保安装了-node-js-后就可以使用命令安装-react-gt-my-app-为创建的-react-项目名-初始-jsx-与组件-gt-下面介绍有关-React-的基础知识-创建-React-组件-React-通常有一个主入口文件，如：index-js-或-index-tsx-首先利用-ReactDOM-createRoot-创建一个-root-document-getElementById-作用是什么？-gt-获取一个-id-为“root”的-HTML-元素作为-React-的挂载点，将其组件挂载到这个容器上-Id-为什么是“root”-gt-在-public-目录下，和-index-html-文件里命名的元素有关，可以自定义命名-之后再用-root-render-将内部的-React-组件（）渲染到-root（根容器）中-App-组件是你引入的一个-React-组件-先在-App-jsx-文件里创建-JS-函数，函数里返回标签，这就是一个-React-组件了-gt-注意：-gt-React-组件必须以大写字母开头-gt-最外层的标签必须闭合，这和-HTML-不同-要想组件在其他的组件里去使用要用-export-defsult-添加样式-使用-className-指定一个样式表-条件渲染-if-语句-三元表达式-短路运算（逻辑中断）-列表渲染-利用-Array-的-map-方法来渲染列表-gt-循环的标签一定要有-key-属性，分配一个唯一的值，不然会有警告-响应事件-在函数组件内部声明一个事件处理函数来响应事件-组件-函数组件-函数名大写开头，函数内返回标签-渲染函数组件-gt-直接使用标签-箭头函数语法-类组件1-必须继承-React-Component-父类2-必须有一个-render-方法3-render-方法必须要有返回值-类组件的渲染和函数组件一致-绑定事件-函数组件绑定事件-类组件绑定事件-gt-在类中定义事件函数，要用-this-funName-的方式引用-事件对象-通过-preventDefault-方法获取到事件对象，阻止运行-插值和状态-class-写法和-Hook-写法-gt-在前面说到-react-的组件由两种写法，一个是-class，一个是-function，在-react18-出来之前，函数组件是不能改变组件内部的值的，要做到动态的效果只能用-class，在-react18-出来之后，添加了一个新特性：Hook。可以在函数组件里定义变量，并修改变量了，在一些老的教程里没有提到这一点，我在这一点上吃了一点亏，既然官方推出了这个特新肯定是希望能成为主流去用的，比如在-react-官网教程里用的就是这个方式，所以在学习这一部分时，尽量还是以-Hook-为主，class-过一遍就好了-class-写法-初始化数据：state-x3D-，state-是组件内部的私有数据，只能在组件内部使用，相当于-java-对象的私有变量。state-的值是一个对象，表示组件内部的多个数据-修改数据：this-setState-要修改的值-，注意：不能直接修改state-gt-注意，在事件函数里存在-this-指向的问题，非箭头函数函数不能直接使用-this-setState-，因为这个-this-不是-class-的-this。-gt-箭头函数没有他自己的-this，他的-this-是由外面一层的-this-决定的-Hook-写法" class="headerlink" title="这篇 React 基础入门是结合 React 和 TS 来使用的，会比一般的 JS 加 React 的项目复杂的多，不过就我目前接触到的项目，采用 TS 居多，JS 越来越少了，大厂或许 TS 用的更多吧（我猜的）。我参照的学习资料来自掘金的一篇文章以及官方的入门教程，我的个人习惯一向是参照文字教程+动手写 demo ＋做项目，视频是真的看不下去，如果是国外的教程有优质的翻译还好，国内的教程质量不能说是很差吧，只是我不习惯这种按照老师讲课的方式，更倾向于文字形式能挑重点看，跳过已经掌握的部分再说说实战视频吧，实战部分的案例都被用得太烂了，如果仅仅只是为了提升技术那么完全没有做的必要，直接参与竞赛或者老师的课题，以解决问题为导向，对自己技术的提升真的很大，实在没有也可以看看 github 的优质项目。# 创建 React 项目- 确保安装了 node.js 后就可以使用命令安装 react&gt; my-app 为创建的 react 项目名# 初始 jsx 与组件&gt; 下面介绍有关 React 的基础知识## 创建 React 组件- React 通常有一个主入口文件，如：index.js 或 index.tsx- 首先利用 ReactDOM.createRoot 创建一个 root- document.getElementById 作用是什么？&gt; 获取一个 id 为“root”的 HTML 元素作为 React 的挂载点，将其组件挂载到这个容器上- Id 为什么是“root”&gt; 在 public 目录下，和 index.html 文件里命名的元素有关，可以自定义命名- 之后再用 root.render 将内部的 React 组件（）渲染到 root（根容器）中- App 组件是你引入的一个 React 组件- 先在 App.jsx 文件里创建 JS 函数，函数里返回标签，这就是一个 React 组件了&gt; 注意：&gt; React 组件必须以大写字母开头&gt; 最外层的标签必须闭合，这和 HTML 不同- 要想组件在其他的组件里去使用要用 export defsult##  添加样式- 使用 className 指定一个样式表# 条件渲染- if 语句- 三元表达式- 短路运算（逻辑中断）## 列表渲染- 利用 Array 的 map 方法来渲染列表&gt; 循环的标签一定要有 key 属性，分配一个唯一的值，不然会有警告## 响应事件- 在函数组件内部声明一个事件处理函数来响应事件# 组件## 函数组件- 函数名大写开头，函数内返回标签- 渲染函数组件&gt; 直接使用标签- 箭头函数语法## 类组件1. 必须继承 React.Component 父类2. 必须有一个 render 方法3. render 方法必须要有返回值- 类组件的渲染和函数组件一致## 绑定事件- 函数组件绑定事件- 类组件绑定事件&gt; 在类中定义事件函数，要用 this.funName 的方式引用 ## 事件对象- 通过 preventDefault 方法获取到事件对象，阻止运行# 插值和状态## class 写法和 Hook 写法&gt; 在前面说到 react 的组件由两种写法，一个是 class，一个是 function，在 react18 出来之前，函数组件是不能改变组件内部的值的，要做到动态的效果只能用 class，在 react18 出来之后，添加了一个新特性：Hook。可以在函数组件里定义变量，并修改变量了，在一些老的教程里没有提到这一点，我在这一点上吃了一点亏，既然官方推出了这个特新肯定是希望能成为主流去用的，比如在 react 官网教程里用的就是这个方式，所以在学习这一部分时，尽量还是以 Hook 为主，class 过一遍就好了## class 写法- 初始化数据：state &#x3D; {}，state 是组件内部的私有数据，只能在组件内部使用，相当于 java 对象的私有变量。state 的值是一个对象，表示组件内部的多个数据- 修改数据：this.setState({要修改的值})，注意：不能直接修改state&gt; 注意，在事件函数里存在 this 指向的问题，非箭头函数函数不能直接使用 this.setState()，因为这个 this 不是 class 的 this。&gt; 箭头函数没有他自己的 this，他的 this 是由外面一层的 this 决定的##  Hook 写法"></a>这篇 React 基础入门是结合 React 和 TS 来使用的，会比一般的 JS 加 React 的项目复杂的多，不过就我目前接触到的项目，采用 TS 居多，JS 越来越少了，大厂或许 TS 用的更多吧（我猜的）。<br>我参照的学习资料来自<a href="https://juejin.cn/post/7021674818621669389">掘金的一篇文章</a>以及<a href="https://react.docschina.org/learn#components">官方的入门教程</a>，我的个人习惯一向是参照文字教程+动手写 demo ＋做项目，视频是真的看不下去，如果是国外的教程有优质的翻译还好，国内的教程质量不能说是很差吧，只是我不习惯这种按照老师讲课的方式，更倾向于文字形式能挑重点看，跳过已经掌握的部分<br>再说说实战视频吧，实战部分的案例都被用得太烂了，如果仅仅只是为了提升技术那么完全没有做的必要，直接参与竞赛或者老师的课题，以解决问题为导向，对自己技术的提升真的很大，实在没有也可以看看 github 的优质项目。<br># 创建 React 项目<br>- 确保安装了 node.js 后就可以使用命令安装 react<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx creat-react-app my-app</span><br></pre></td></tr></table></figure><br>&gt; my-app 为创建的 react 项目名<br># 初始 jsx 与组件<br>&gt; 下面介绍有关 React 的基础知识<br>## 创建 React 组件<br>- React 通常有一个主入口文件，如：index.js 或 index.tsx<br>- 首先利用 ReactDOM.createRoot 创建一个 root<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>- document.getElementById 作用是什么？<br>&gt; 获取一个 id 为“root”的 HTML 元素作为 React 的挂载点，将其组件挂载到这个容器上<br>- Id 为什么是“root”<br>&gt; 在 public 目录下，和 index.html 文件里命名的元素有关，可以自定义命名<br>- 之后再用 root.render 将内部的 React 组件（<App/>）渲染到 root（根容器）中<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root.<span class="title function_">render</span>(  </span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span>  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure><br>- App 组件是你引入的一个 React 组件<br>- 先在 App.jsx 文件里创建 JS 函数，函数里返回标签，这就是一个 React 组件了<br>&gt; 注意：<br>&gt; React 组件必须以大写字母开头<br>&gt; 最外层的标签必须闭合，这和 HTML 不同<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    Hello，World！</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>- 要想组件在其他的组件里去使用要用 export defsult<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><br>##  添加样式<br>- 使用 className 指定一个样式表<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./App.css&quot;</span></span><br><span class="line">&lt;img className=<span class="string">&quot;demo&quot;</span>&gt;</span><br></pre></td></tr></table></figure><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在App.css文件中*/</span></span><br><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line"><span class="attribute">width</span>：<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>：<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br># 条件渲染<br>- if 语句<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> content;  </span><br><span class="line"><span class="keyword">if</span> (isLoggedIn) &#123;  </span><br><span class="line">content = <span class="language-xml"><span class="tag">&lt;<span class="name">AdminPanel</span> /&gt;</span></span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">content = <span class="language-xml"><span class="tag">&lt;<span class="name">LoginForm</span> /&gt;</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> (  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">&#123;content&#125;  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>- 三元表达式<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> content;  </span><br><span class="line">content = isLoggedIn ? <span class="language-xml"><span class="tag">&lt;<span class="name">AdminPanel</span> /&gt;</span></span>:<span class="language-xml"><span class="tag">&lt;<span class="name">LoginForm</span> /&gt;</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> (  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">&#123;content&#125;  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>- 短路运算（逻辑中断）<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;  </span><br><span class="line">&#123;isLoggedIn &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">AdminPanel</span> /&gt;</span></span>&#125;  </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><br>## 列表渲染<br>- 利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array 的 map 方法</a>来渲染列表<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listItems = products.<span class="title function_">map</span>(<span class="function"><span class="params">product</span> =&gt;</span>  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;product.id&#125;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">&#123;product.title&#125;  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>&gt; 循环的标签一定要有 key 属性，分配一个唯一的值，不然会有警告<br>## 响应事件<br>- 在函数组件内部声明一个事件处理函数来响应事件<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是函数组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyButton</span>(<span class="params"></span>) &#123;  </span><br><span class="line"><span class="comment">//这是事件处理函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;  </span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;You clicked me!&#x27;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">Click me  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>  </span><br><span class="line">);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br># 组件<br>## 函数组件<br>- 函数名大写开头，函数内返回标签<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Hello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>- 渲染函数组件<br>&gt; 直接使用<Hello/>标签<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span>/&gt;</span></span>, root)</span><br></pre></td></tr></table></figure><br>- 箭头函数语法<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Hello</span> = (<span class="params"></span>)=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><br>## 类组件<br>1. 必须继承 React.Component 父类<br>2. 必须有一个 render 方法<br>3. render 方法必须要有返回值<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>- 类组件的渲染和函数组件一致<br>## 绑定事件<br>- 函数组件绑定事件<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>)&#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;abc&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>- 类组件绑定事件<br>&gt; 在类中定义事件函数，要用 <code>this.funName</code> 的方式引用<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.hanleClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> ## 事件对象<br>- 通过 preventDefault 方法获取到事件对象，阻止运行<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="comment">//e就是这个点击事件的对象，也叫合成对象</span></span><br><span class="line">e.<span class="title function_">preventDefault</span>()<span class="comment">//阻止了链接的跳转</span></span><br><span class="line">&#125; </span><br><span class="line">&lt;a onClick=&#123;handleClick&#125;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><br># 插值和状态<br>## class 写法和 Hook 写法<br>&gt; 在前面说到 react 的组件由两种写法，一个是 class，一个是 function，在 react18 出来之前，函数组件是不能改变组件内部的值的，要做到动态的效果只能用 class，在 react18 出来之后，添加了一个新特性：Hook。可以在函数组件里定义变量，并修改变量了，在一些老的教程里没有提到这一点，我在这一点上吃了一点亏，既然官方推出了这个特新肯定是希望能成为主流去用的，比如在 react 官网教程里用的就是这个方式，所以在学习这一部分时，尽量还是以 Hook 为主，class 过一遍就好了<br>## class 写法<br>- 初始化数据：state &#x3D; {}，state 是组件内部的私有数据，只能在组件内部使用，相当于 java 对象的私有变量。state 的值是一个对象，表示组件内部的多个数据<br>- 修改数据：this.setState({要修改的值})，<code>注意：不能直接修改state</code><br>&gt; 注意，在事件函数里存在 this 指向的问题，非箭头函数函数不能直接使用 this.setState()，因为这个 this 不是 class 的 this。<br>&gt; 箭头函数没有他自己的 this，他的 this 是由外面一层的 this 决定的<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;  </span><br><span class="line">  state=&#123;  </span><br><span class="line">    count : <span class="number">0</span>  </span><br><span class="line">  &#125;  </span><br><span class="line">  handleClick = <span class="function">()=&gt;</span>&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;  </span><br><span class="line">      <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> +<span class="number">1</span>  </span><br><span class="line">    &#125;)  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span>( <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>    )  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##  Hook 写法</h2><h1 id="挂载和状态设置"><a href="#挂载和状态设置" class="headerlink" title="挂载和状态设置"></a>挂载和状态设置</h1><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;categories&quot;&gt;&lt;a href=&quot;#categories&quot; class=&quot;headerlink&quot; title=&quot;categories:&quot;&gt;&lt;/a&gt;categories:&lt;/h2&gt;&lt;h2 id=&quot;这篇-React-基础入门是结合-React-和-TS-来使用</summary>
      
    
    
    
    <category term="前端学习" scheme="https://coding.lilming.top/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript基础入门</title>
    <link href="https://coding.lilming.top/2023/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/TypeScript%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://coding.lilming.top/2023/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/TypeScript%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2023-06-20T05:19:00.000Z</published>
    <updated>2023-09-08T03:58:27.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>官方文档：<a href="https://www.tslang.cn/docs/home.html">TypeScript中文网 </a></p><h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>使用模板字符串可以定义多行文本和内嵌表达式</p><p>使用 **(`)符号包裹 ******，并且以 <code>$&#123;expr&#125;</code> 这种这种形式嵌入表达式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">hello</span>: <span class="built_in">string</span> = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>Array</code> 直接在类型后加上 <code>[]</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>使用数组泛型，<code>Array&lt;元素类型&gt;</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p><code>Tuple</code> 存储的数据类型可不相同，元素数量和类型是固定的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [stirng, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code> 能为一组数值赋值为对应的编号</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认按照0，1，3来编号</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;red, green, blue&#125;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;red = <span class="number">0</span>, green = <span class="number">1</span>, blue = <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">//也可以手动编号</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;red =  <span class="number">1</span>, green = <span class="number">2</span>, blue = <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>根据键名赋键值，类型可以为 number 也可以为枚举对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;red, green, blue&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">red</span><span class="comment">//x = 0</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> = <span class="title class_">Color</span>.<span class="property">green</span><span class="comment">//x = 1</span></span><br></pre></td></tr></table></figure><p>根据键值赋键名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;red, green, blue&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">0</span>]<span class="comment">//x = &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>在变量类型位置时，可以使用 <code>any</code> 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span>[] = [];</span><br><span class="line">x.<span class="title function_">push</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h2><p><code>void</code> 通常用于没有返回值的函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">funcation <span class="title function_">fun</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello，world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void</code> 类型类型的变量只能赋值为 <code>null</code> 和 <code>undefined</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h2 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h2><ul><li>在默认情况下，null 和 undefined 是<strong>所有类型的子类</strong>，可以将 null 和 undefined 赋值给任何类型的变量</li><li>但在严格模式下，null 和 undefined 只能赋值给它们对应的类型，在这个模式下如果想传入一个 string 或 null 或 undefined 类型，可以使用联合类型 <code>string|null|undefined</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//严格模式下</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">string</span>|<span class="literal">null</span>|<span class="literal">undefined</span> = <span class="literal">null</span> </span><br></pre></td></tr></table></figure><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><code>never</code> 类型表示不存在值的类型，用于抛出异常的函数，或无限循环下去的函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object 表示非原始类型，是除了 <code>number </code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code> 或 <code>undefined</code> 之外的类型</p><p>可以便于更好使用像 <code>Object.create</code> 这样的 API</p><p>使用 <code>typeof</code> 函数返回非原始类型变量都是 <code>Object</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>):<span class="built_in">void</span>; </span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK </span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// OK </span></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>); <span class="comment">// Error </span></span><br><span class="line"><span class="title function_">create</span>(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">false</span>); <span class="comment">// Error </span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>第一种方式：使用 <code>&lt;&gt;</code> <strong>(不推荐)</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>; <span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br></pre></td></tr></table></figure><p>第二种方式：使用 <code>as</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure><p>在 tsx 中（react 项目里）由于尖括号和标签冲突，只能使用 <code>as</code> 的形式</p><h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><h2 id="var、let-和-const"><a href="#var、let-和-const" class="headerlink" title="var、let 和 const"></a>var、let 和 const</h2><ul><li>使用 <code>var</code> 声明一个变量，在其他函数内部是可以访问的，正是因为 var 存在着这样的问题，我们更推荐使用 <code>let</code></li><li>let 声明的变量只能在它的语法作用域或者块作用域使用</li><li><code>const</code> 的作用域与 <code>let</code> 类似，只是 <code>const</code> 在被创建后不能改变</li></ul><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>语法：<code>let [x, y] = array</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>]; </span><br><span class="line"><span class="keyword">let</span> [first, second] = input; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first); <span class="comment">// outputs 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(second); <span class="comment">// outputs 2</span></span><br></pre></td></tr></table></figure><ul><li>作用于函数参数可直接解构成参数</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(second); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">f</span>(input);</span><br></pre></td></tr></table></figure><ul><li>可以用 <code>...</code> 语法来创建剩余的变量</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [frist, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(frist)<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest)<span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><ul><li>若不关心其他变量，可以空着，只用 <code>,</code> 分隔</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [, second, , fourth] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>语法： <code>let &#123;x, y&#125; = class</code>，结构的变量名要和对象的键名对应</p><p>下面的代码里的 a 和 b 没有指明类型，ts 也能正常运行，这是因为当你使用对象解构时，编译器会自动判断对象属性的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">a</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">b</span>: <span class="number">12</span>, <span class="attr">c</span>: <span class="string">&quot;bar&quot;</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure><p>将对象解构用于函数声明中</p><p>type 作用就是给类型起一个新名字，和接口一样，用来描述对象或函数的类型，<code>?</code> 表示该类型可选</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> C = &#123; <span class="attr">a</span>: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b &#125;: C</span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b &#125;: &#123;a:<span class="built_in">string</span>, b:<span class="built_in">number</span> &#125;</span>): <span class="built_in">void</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><p>三个点 <code>...</code> 被称为扩展运算符。用于可迭代对象展开到每个元素</p><ol><li>合并数组</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> mergedArray = [...arr1, ...arr2]; <span class="comment">// 结果：[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>复制数组</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> newArray = [...originalArray];</span><br></pre></td></tr></table></figure><ol start="3"><li>添加元素</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2); <span class="comment">// 结果：[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>函数参数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_">myFunction</span>(...args); <span class="comment">// 输出：6</span></span><br></pre></td></tr></table></figure><ol start="5"><li>对象扩展</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> mergedObject = &#123; ...obj1, ...obj2 &#125;; <span class="comment">// 结果：&#123;a: 1, b: 2, c: 3, d: 4&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>与 <code>type</code> 类似，都能用于定义变量的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceExample</span> &#123; <span class="attr">key</span>: <span class="built_in">string</span>; &#125; </span><br><span class="line"><span class="comment">// 使用type </span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeExample</span> = &#123; <span class="attr">key</span>: <span class="built_in">string</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="接口和类型的区别"><a href="#接口和类型的区别" class="headerlink" title="接口和类型的区别"></a>接口和类型的区别</h2><ol><li><p>interface 与 type 能相互扩展:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface能用extends来扩展</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Name</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span>; &#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Name</span> &#123; <span class="attr">age</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="comment">//type能用 &amp; 来交叉类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = <span class="title class_">Name</span> &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">//interface扩展type</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; &#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Name</span> &#123; <span class="attr">age</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="comment">// type 与 interface 交叉 </span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Name</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = <span class="title class_">Name</span> &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>interface</code> 可以定义多次，属性会被合并，而 <code>type</code> 不能被定义多次</p></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span> <span class="attr">age</span>: <span class="built_in">number</span> &#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123; <span class="attr">sex</span>: <span class="built_in">string</span> &#125; </span><br><span class="line"><span class="keyword">let</span> <span class="attr">user</span>:<span class="title class_">User</span>=&#123;<span class="attr">name</span>:<span class="string">&#x27;wang&#x27;</span>,<span class="attr">age</span>:<span class="number">1</span>,<span class="attr">sex</span>:<span class="string">&#x27;man&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>type</code> 能定义映射类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> aType &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用type定义映射类型 </span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyType</span>&lt;T&gt; = &#123; <span class="keyword">readonly</span> [key <span class="keyword">in</span> keyof T]: T[key]; &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> newType = <span class="title class_">ReadonlyType</span>&lt;aType&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type newType = &#123;</span></span><br><span class="line"><span class="comment"> readonly name: string;</span></span><br><span class="line"><span class="comment"> readonly age?: number;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>type</code> 能定义条件类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arrayType = <span class="built_in">number</span>[];</span><br><span class="line"><span class="comment">// 使用type定义条件类型 </span></span><br><span class="line"><span class="comment">// infer能够自动推断传入的类型,之后会再讲到</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ElementType</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer U&gt; ? U : T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> newType = <span class="title class_">Elementtype</span>&lt;arraytype&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type newType = number</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>在属性后加 <code>?</code> ,则该属性是可有可无的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tom : <span class="title class_">Iperson</span> = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line"><span class="comment">//age: 21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h2><p>语法：<code>[propName: type]: any</code> ，能允许类型添加别的属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="title class_">String</span>;</span><br><span class="line">[<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tom : <span class="title class_">Iperson</span> = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line"><span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>被创建后不能被修改,用于对象在创建后就不能更改的属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"><span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">IPerson</span> = &#123; <span class="attr">id</span>:<span class="number">001</span>, <span class="attr">name</span>:wdm&#125;;</span><br><span class="line">p1.<span class="property">id</span> = <span class="number">002</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><h3 id="只读数组类型"><a href="#只读数组类型" class="headerlink" title="只读数组类型"></a>只读数组类型</h3><p><code>ReadonlyArray&lt;T&gt;</code> 类型与 <code>Array&lt;T&gt;</code> 类似，只不过都是不可变的数据</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.<span class="title function_">push</span>(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.<span class="property">length</span> = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>在最后一行代码，将 <code>ReadonlyArray</code> 赋值给一个普通的数组也是不行的，但是可以用类型重写，将 <code>ReadonlyArray</code> 强制转换为数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure><h2 id="可变属性"><a href="#可变属性" class="headerlink" title="可变属性"></a>可变属性</h2><p>如果要使类型的属性可变,可以使用 <code>[propName: string]: any</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//即使是拼写成了 colour 也不会报错,会自动添加一个colour属性</span></span><br><span class="line"><span class="keyword">let</span> squareOptions = &#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(squareOptions);</span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能描述变量类型外,还能描述函数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这能用于创建一个函数类型的变量,将一个函数赋值给一个变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.<span class="title function_">search</span>(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数里的参数名不必与接口定义的参数名相同</p><p>同时也可以不指定类型, TypeScript 会推断出参数的类型，因为已经指定了变量的函数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span>(<span class="params">src, sub</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = src.<span class="title function_">search</span>(sub);</span><br><span class="line">    <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h2><p>用于描述哪些可以通过索引得到数据的类型,类似于数组和字典,比如 <code>a[10]</code> 或 <code>ageMap[&quot;daniel&quot;]</code></p><p>只能使用 <code>string</code> 或 <code>number</code> 来作为索引</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StringArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">StringArray</span>;</span><br><span class="line">myArray = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Fred&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myStr</span>: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>也可以同时使用 <code>string</code> 和 <code>number</code> 作为索引</p><p>下面的代码在使用 <code>number</code> 索引时,由于 <code>Animal</code> 是父类型,也会匹配到 <code>Dog</code>,因此发生冲突<br>正确的做法是 <code>number</code> 返回的类型是 <code>string</code> 返回的类型的子类型</p><p>因为 <code>number</code> 实际上在 typescript 内部执行的时候会转换为 <code>string</code> ，所以这也要求 <code>string</code> 索引本身对应的类型是兼容所有的，也就是说 string 索引对应的类型必须是其他类型的父类。</p><p>举一个反例，比如 <code>number</code> 索引返回的类型是 <code>Animal</code>，TS 转换成 <code>string</code> 来去查找，但是 <code>string</code> 索引返回的类型是 <code>Dog</code>，<code>Animal</code> 不是 <code>Dog</code> 类型，编译器会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：&#x27;string&#x27;索引对应的类型不兼容所有</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NotOkay</span> &#123;</span><br><span class="line">    [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="title class_">Animal</span>;</span><br><span class="line">    [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Dog</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的做法:使用number索引时Dog都是Animal，字符串索引和数字索引返回的类型被视为一致</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NotOkay</span> &#123;</span><br><span class="line">    [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="title class_">Dog</span>;</span><br><span class="line">    [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Animal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串索引能够描述 <code>dictionary</code> 形式的变量,但是要保证所有 <code>string</code> 类型的属性返回值都和字符串索引的返回类型一致</p><p>因为字符串索引声明了 <code>obj.property</code> 和 <code>obj[&quot;property&quot;]</code> 两种形式都可以</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NumberDictionary</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何为既有索引又有普通属性的变量初始化：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">dict</span>: <span class="title class_">NumberDictionary</span> = &#123;</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h2><p>和 java 中的接口作用一致,用于抽象一个类的数据结构(ADT)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">    <span class="title function_">setTime</span>(<span class="attr">d</span>: <span class="title class_">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">    <span class="title function_">setTime</span>(<span class="params">d: <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">currentTime</span> = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>和类一样，接口也可以继承一个或多个接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;<span class="title class_">Square</span>&gt;&#123;&#125;;</span><br><span class="line">square.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.<span class="property">sideLength</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><p>使用接口的混合类型，你会得到一个对象同时也能当作函数来使用</p><p>创建混合类型对象的步骤：</p><ol><li>先通过函数表达式，将函数分配给一个变量</li><li>再使用 <code>Object.assign()</code> 方法将对象属性分配给该变量</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    (<span class="attr">start</span>: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">interval</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">reset</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCounter</span>(<span class="params"></span>): <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有指定函数签名的对象</span></span><br><span class="line">    <span class="keyword">const</span> counterFunction = <span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>; &#125;;</span><br><span class="line">    <span class="comment">// 使用Object.assign将额外属性分配给counterFunction对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">counter</span>: <span class="title class_">Counter</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(counterFunction, &#123;</span><br><span class="line">        <span class="attr">interval</span>: <span class="number">123</span>,</span><br><span class="line">        <span class="attr">reset</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">getCounter</span>();</span><br><span class="line"><span class="title function_">c</span>(<span class="number">10</span>);</span><br><span class="line">c.<span class="title function_">reset</span>();</span><br><span class="line">c.<span class="property">interval</span> = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure><h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当一个接口继承了类后，该接口只能被这个类或其子类所实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Control</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">state</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SelectableControl</span> <span class="keyword">extends</span> <span class="title class_">Control</span> &#123;</span><br><span class="line">    <span class="title function_">select</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Control</span> <span class="keyword">implements</span> <span class="title class_">SelectableControl</span> &#123;</span><br><span class="line">    <span class="title function_">select</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Image必须是Control或其子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> <span class="keyword">implements</span> <span class="title class_">SelectableControl</span> &#123;</span><br><span class="line">    <span class="title function_">select</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h2 id="属性修饰符"><a href="#属性修饰符" class="headerlink" title="属性修饰符"></a>属性修饰符</h2><table><thead><tr><th align="center">修饰符</th><th align="center">子类</th><th align="center">实例</th><th>能否被修改</th></tr></thead><tbody><tr><td align="center">public(默认)</td><td align="center">√</td><td align="center">√</td><td>√</td></tr><tr><td align="center">protected</td><td align="center">√</td><td align="center">×</td><td>√</td></tr><tr><td align="center">private</td><td align="center">×</td><td align="center">×</td><td>√</td></tr></tbody></table><blockquote><p><code>readonly</code>关键字用于将类成员声明为<strong>只读</strong>。这意味着成员的值只能在<strong>声明或构造函数</strong>中进行设置，不能在其他地方修改。<code>readonly</code>可以与<code>public</code>、<code>private</code>和<code>protected</code>修饰符结合使用。</p></blockquote><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>在TypeScript里，成员都默认为<code>public</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = theName; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p><code>protected</code> 成员只能在类和子类中可以访问</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">department</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">department</span> = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getElevatorPitch</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="variable language_">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Howard&quot;</span>, <span class="string">&quot;Sales&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(howard.<span class="title function_">getElevatorPitch</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(howard.<span class="property">name</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>构造函数也可以被标记成 <code>protected</code>。这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee 能够继承 Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">department</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">department</span> = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getElevatorPitch</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="variable language_">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Howard&quot;</span>, <span class="string">&quot;Sales&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>); <span class="comment">// 错误: &#x27;Person&#x27; 的构造函数是被保护的.</span></span><br></pre></td></tr></table></figure><p>TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p><p>然而，当我们比较带有 <code>private</code> 或 <code>protected</code> 成员的类型的时候，情况就不同了。如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。对于 <code>protected</code> 成员也使用这个规则。</p><p>下面来看一个例子，更好地说明了这一点：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rhino</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">super</span>(<span class="string">&quot;Rhino&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Goat&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> <span class="title class_">Rhino</span>();</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">animal = rhino;</span><br><span class="line">animal = employee; <span class="comment">// 错误: Animal 与 Employee 不兼容.</span></span><br></pre></td></tr></table></figure><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>当成员被标记成<code>private</code>时，它就不能在声明它的类的外部访问</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Cat&quot;</span>).<span class="property">name</span>; <span class="comment">// 错误: &#x27;name&#x27; 是私有的.</span></span><br></pre></td></tr></table></figure><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。只读属性必须在声明时或构造函数里被初始化。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Octopus</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">numberOfLegs</span>: <span class="built_in">number</span> = <span class="number">8</span>;</span><br><span class="line">    <span class="title function_">constructor</span> (<span class="attr">theName</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dad = <span class="keyword">new</span> <span class="title class_">Octopus</span>(<span class="string">&quot;Man with the 8 strong legs&quot;</span>);</span><br><span class="line">dad.<span class="property">name</span> = <span class="string">&quot;Man with the 3-piece suit&quot;</span>; <span class="comment">// 错误! name 是只读的.</span></span><br></pre></td></tr></table></figure><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>TypeScript 支持通过 <code>get</code> 和 <code>set</code> 来截取对对象属性的操作。它能帮助你有效的控制对对象成员的读取和修改。</p><p>先将属性定义为 <code>private</code>, <code>get</code> 用来截取对象属性的读取, <code>set</code> 用来截取对象属性的修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&quot;secret passcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_fullName</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">fullName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_fullName</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode === <span class="string">&quot;secret passcode&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_fullName</span> = newName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error: Unauthorized update of employee!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"><span class="comment">//对fullName赋值时,会运行set fullName()</span></span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&quot;Bob Smith&quot;</span>;</span><br><span class="line"><span class="comment">//读取fullName时,会运行get fullName()</span></span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(employee.<span class="property">fullName</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p><code>static</code> 修饰符使得该属性只存在于该对象中,所有由该对象创建的实例都使用同一个属性值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grid</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> origin = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="title function_">calculateDistanceFromOrigin</span>(<span class="params">point: &#123;x: <span class="built_in">number</span>; y: <span class="built_in">number</span>;&#125;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> xDist = (point.<span class="property">x</span> - <span class="title class_">Grid</span>.<span class="property">origin</span>.<span class="property">x</span>);</span><br><span class="line">        <span class="keyword">let</span> yDist = (point.<span class="property">y</span> - <span class="title class_">Grid</span>.<span class="property">origin</span>.<span class="property">y</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(xDist * xDist + yDist * yDist) / <span class="variable language_">this</span>.<span class="property">scale</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span> (<span class="keyword">public</span> <span class="attr">scale</span>: <span class="built_in">number</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> <span class="title class_">Grid</span>(<span class="number">1.0</span>);  <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> <span class="title class_">Grid</span>(<span class="number">5.0</span>);  <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grid1.<span class="title function_">calculateDistanceFromOrigin</span>(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grid2.<span class="title function_">calculateDistanceFromOrigin</span>(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;));</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h2><p>函数声明和函数表达式的区别：<br>    - 函数声明会在浏览器在执行代码时被扫描，创建一个变量来储存指向该函数的引用<br>    - 函数表达式则是将函数赋值给一个变量来储存</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>,y: <span class="built_in">number</span></span>): <span class="built_in">number</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">let</span> add = (<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span> ): <span class="function"><span class="params">number</span> =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口定义函数"><a href="#接口定义函数" class="headerlink" title="接口定义函数"></a>接口定义函数</h2><p>接口内要用 <code>()</code> 包裹函数的参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Add</span>&#123;</span><br><span class="line">(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">add</span>: <span class="title class_">IAdd</span> = <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>参数后加 <code>?</code> 表示该参数是可选的，要对没有传入可选参数的情况做一个判断，通常可选参数都有个默认值，也就是默认参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">name</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?:<span class="built_in">string</span></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(lastName)&#123;</span><br><span class="line"><span class="keyword">return</span> firstName+<span class="string">&#x27; &#x27;</span>+lastName;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">name</span>(<span class="string">&#x27;lilming&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>可选参数和默认参数类似，可以有也可以没有。但是可选参数必须在必选参数后面；默认参数没有这个限制</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">name</span>(<span class="params">lastName:<span class="built_in">string</span> = <span class="string">&#x27;wang&#x27;</span> ,firstName: <span class="built_in">string</span> </span>)&#123;</span><br><span class="line"><span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">name</span>(<span class="string">&#x27;daiming&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="获取剩余参数"><a href="#获取剩余参数" class="headerlink" title="获取剩余参数"></a>获取剩余参数</h2><p><code>...</code> 在变量之前可以获取剩下的其他变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">a:<span class="built_in">any</span>[], ...items:<span class="built_in">any</span>[]</span>)&#123;</span><br><span class="line">items.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">a.<span class="title function_">push</span>(item)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title function_">push</span>(a,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>利用联合类型参数，通过 <code>if</code> 判断参数类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span>| <span class="built_in">String</span></span>): <span class="built_in">number</span>| <span class="title class_">String</span>| <span class="built_in">void</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> x ===<span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Number</span>(x.<span class="property">tostring</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="property">reverse</span>.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this-和箭头函数"><a href="#this-和箭头函数" class="headerlink" title="this 和箭头函数"></a>this 和箭头函数</h2><p>箭头函数会捕获包含它们的上下文中的 <code>this</code> 值，箭头函数中的 <code>this</code> 和外层的 <code>this</code> 是一致的。而普通函数中的 <code>this</code> 指向全局对象（在浏览器中是 <code>window</code>，在 Node.js 中是 <code>global</code>）</p><p>下面的例子中，一个对象的函数返回了一个函数，被返回的函数内使用了该对象的属性，则该函数要用<strong>箭头函数</strong>，而不是普通的函数</p><p>因为在该函数被创建之后（被赋值了之后），他的 <code>this</code> 需要是对象的，而不是它自身的，这就需要使用<strong>箭头函数</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">    <span class="attr">suit</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">card</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Deck</span> &#123;</span><br><span class="line">    <span class="attr">suits</span>: <span class="built_in">string</span>[];</span><br><span class="line">    <span class="attr">cards</span>: <span class="built_in">number</span>[];</span><br><span class="line">    <span class="title function_">createCardPicker</span>(<span class="attr">this</span>: <span class="title class_">Deck</span>): <span class="function">() =&gt;</span> <span class="title class_">Card</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">deck</span>: <span class="title class_">Deck</span> = &#123;</span><br><span class="line">    <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="attr">cards</span>: <span class="title class_">Array</span>(<span class="number">52</span>),</span><br><span class="line"></span><br><span class="line">    <span class="attr">createCardPicker</span>: <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: Deck</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="variable language_">this</span>.<span class="property">suits</span>[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.<span class="title function_">createCardPicker</span>();</span><br><span class="line"><span class="keyword">let</span> pickedCard = <span class="title function_">cardPicker</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard.<span class="property">suit</span>);</span><br></pre></td></tr></table></figure><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>如果一个函数可能会有不同类型的参数传入，采用可选参数和 <code>if</code> 来处理会使代码可读性下降很多，可以采用函数重载来限定不同类型的参数</p><p>例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">all: <span class="built_in">number</span></span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">topAndBottom: <span class="built_in">number</span>, leftAndRight: <span class="built_in">number</span></span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">top: <span class="built_in">number</span>, right: <span class="built_in">number</span>, bottom: <span class="built_in">number</span>, left: <span class="built_in">number</span></span>);</span><br><span class="line"><span class="comment">// 上面三个是函数重载，规定只能用这三种形式的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span>, c?: <span class="built_in">number</span>, d?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="literal">undefined</span> &amp;&amp; c === <span class="literal">undefined</span> &amp;&amp; d === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    b = c = d = a;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="literal">undefined</span> &amp;&amp; d === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    c = a;</span><br><span class="line">    d = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">top</span>: a,</span><br><span class="line">    <span class="attr">right</span>: b,</span><br><span class="line">    <span class="attr">bottom</span>: c,</span><br><span class="line">    <span class="attr">left</span>: d</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在调用时，就只能使用前面三种的参数形式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">padding</span>(<span class="number">1</span>); <span class="comment">// Okay: all</span></span><br><span class="line"><span class="title function_">padding</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// Okay: topAndBottom, leftAndRight</span></span><br><span class="line"><span class="title function_">padding</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// Okay: top, right, bottom, left</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">padding</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// Error: Not a part of the available overloads</span></span><br></pre></td></tr></table></figure><p>64 4 16 20 16 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;官方文档：&lt;a href=&quot;https://www.tslang.cn/docs/home.html&quot;&gt;TypeScript中文网 &lt;/a&gt;</summary>
      
    
    
    
    <category term="计算机语言知识库" scheme="https://coding.lilming.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解TypeScript</title>
    <link href="https://coding.lilming.top/2023/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TypeScript/"/>
    <id>https://coding.lilming.top/2023/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TypeScript/</id>
    <published>2023-06-20T05:19:00.000Z</published>
    <updated>2023-09-08T03:59:08.943Z</updated>
    
    
    
    
    <category term="计算机语言知识库" scheme="https://coding.lilming.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Springboot后端 + 前端部署流程</title>
    <link href="https://coding.lilming.top/2023/06/20/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/Springboot%E5%90%8E%E7%AB%AF%20+%20%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <id>https://coding.lilming.top/2023/06/20/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/Springboot%E5%90%8E%E7%AB%AF%20+%20%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</id>
    <published>2023-06-20T05:19:00.000Z</published>
    <updated>2023-09-08T03:57:12.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul><li>mysql 版本:5.7 以上</li><li>不区分大小写：在[mysqlid]下加上 <code>lower_case_table_names=1</code></li></ul><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><ul><li>安装 jdk8</li><li>jar 包运行<ul><li>查看 8080 端口占用：lsof -i:8080</li><li>杀死进程（PID）：kill -9 {PID}</li><li>nohup 不中断运行：nohup java -jar xxx.jar &gt;&gt; log 2&gt;&amp;1 &amp;</li><li>在 log 中查看日志</li></ul></li></ul><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><ul><li>nginx 安装包下载：wget <a href="http://nginx.org/download/nginx-1.24.0.tar.gz">http://nginx.org/download/nginx-1.24.0.tar.gz</a></li><li>nginx 安装：tar zxvf nginx-1.24.0.tar.gz <ul><li>cd nginx-1.24.0</li><li>.&#x2F;configure &amp;&amp; make &amp;&amp; make install</li></ul></li><li>将打包好的文件拖到 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html 中</li><li>配置：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 启动nginx压缩</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line">    </span><br><span class="line">server &#123;</span><br><span class="line">    listen       8000;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    </span><br><span class="line">    root html;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">         </span><br><span class="line"> try_files $uri $uri/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">location  /jeecgboot/ &#123;</span><br><span class="line"></span><br><span class="line">proxy_pass         http://127.0.0.1:8080/jeecg-boot/;</span><br><span class="line">proxy_redirect off;</span><br><span class="line"></span><br><span class="line">proxy_set_header  Host             $host;</span><br><span class="line">proxy_set_header  X-Real-IP        $remote_addr;</span><br><span class="line">set $my_proxy_add_x_forwarded_for $proxy_add_x_forwarded_for;</span><br><span class="line">if ($proxy_add_x_forwarded_for ~* &quot;127.0.0.1&quot;)&#123;</span><br><span class="line">   set $my_proxy_add_x_forwarded_for $remote_addr;</span><br><span class="line">&#125;</span><br><span class="line">proxy_set_header   X-Forwarded-For $my_proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>重启配置：.&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</li><li>重新运行：sudo .&#x2F;nginx -s reload</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;mysql 版本:5.7 以上&lt;/li&gt;
&lt;li&gt;不区分大小写：在[mysqlid]下加上 &lt;code&gt;lower_ca</summary>
      
    
    
    
    <category term="项目开发" scheme="https://coding.lilming.top/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
</feed>
